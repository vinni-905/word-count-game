
```html
<!DOCTYPE html>
<html lang="en"> <!-- Theme class added by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordLinks - Play</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        /* --- Base & Typography --- */
        :root { /* Light Theme (Default) */
            --bg-gradient-start: #f8f9fa; --bg-gradient-end: #ffffff;
            --container-bg: #ffffff; --text-primary: #343a40; --text-secondary: #6c757d;
            --accent-primary: #007bff; --accent-secondary: #8f94fb;
            --selected-bg: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%); --selected-text: #ffffff;
            --solved-bg: #e9ecef; --solved-text: #adb5bd; --disabled-opacity: 0.6;
            --correct-bg: #d1e7dd; --correct-text: #0f5132; --correct-border: #badbcc;
            --incorrect-bg: #f8d7da; --incorrect-text: #842029; --incorrect-border: #f5c2c7;
            --hint-bg: #cff4fc; --hint-text: #055160; --hint-border: #b6effb;
            --button-primary-bg: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            --button-primary-hover: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            --button-warning-bg: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            --button-warning-hover: linear-gradient(135deg, #e0a800 0%, #c69500 100%);
            --button-info-bg: linear-gradient(135deg, #17a2b8 0%, #117a8b 100%);
            --button-info-hover: linear-gradient(135deg, #117a8b 0%, #0f6674 100%);
            --button-shuffle-bg: linear-gradient(135deg, #fd7e14 0%, #e85a00 100%);
            --button-shuffle-hover: linear-gradient(135deg, #e85a00 0%, #c54a00 100%);
            --button-success-bg: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            --button-success-hover: linear-gradient(135deg, #1e7e34 0%, #155724 100%);
            --button-disabled-bg: #ced4da; --button-disabled-text: #6c757d;
            --container-border: rgba(255, 255, 255, 0.3); --blur-intensity: 10px;
            --solved-color-0-bg: linear-gradient(135deg, #fefae0 0%, #faedcd 100%);
            --solved-color-0-text: #bc6c25; --solved-color-0-border: #e9c46a;
            --solved-color-1-bg: linear-gradient(135deg, #caf0f8 0%, #ade8f4 100%);
            --solved-color-1-text: #0077b6; --solved-color-1-border: #48cae4;
            --solved-color-2-bg: linear-gradient(135deg, #d8f3dc 0%, #b7e4c7 100%);
            --solved-color-2-text: #2d6a4f; --solved-color-2-border: #74c69d;
            --solved-color-3-bg: linear-gradient(135deg, #fec8d8 0%, #ffacb7 100%);
            --solved-color-3-text: #c9184a; --solved-color-3-border: #ff758f;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1); --shadow-md: 0 4px 8px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.1); --transition-speed: 0.25s;
            --word-item-base-bg: #f8f9fa; --word-item-base-border: #dee2e6;
            --controls-bg: #f8f9fa; --status-bar-bg: #f8f9fa;
            --modal-overlay-bg: rgba(0, 0, 0, 0.6);
            --theme-toggle-btn-color: var(--text-secondary);
            --theme-toggle-btn-hover-color: var(--text-primary);
            --error-message-bg: var(--incorrect-bg); --error-message-text: var(--incorrect-text);
            --error-message-border: var(--incorrect-border);
            --timer-default-color: var(--accent-primary);
            --timer-warning-color: var(--incorrect-text);
            --daily-indicator-bg: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            --daily-indicator-text: var(--accent-primary);
            --leaderboard-header-bg: var(--accent-primary);
            --leaderboard-header-text: white;
            --leaderboard-row-even-bg: #f2f2f2;
            --leaderboard-border-color: #ddd;
        }

        html.dark-theme { /* Dark Theme Overrides */
            --bg-gradient-start: #212529; --bg-gradient-end: #343a40;
            --container-bg: #495057; --text-primary: #f8f9fa; --text-secondary: #adb5bd;
            --accent-primary: #0d6efd;
            --selected-bg: linear-gradient(135deg, #5e31a7 0%, #1a5bbd 100%);
            --solved-bg: #343a40; --solved-text: #6c757d;
            --correct-bg: #14452F; --correct-text: #a3d4b8; --correct-border: #2f6f4f;
            --incorrect-bg: #591C21; --incorrect-text: #f5c2c7; --incorrect-border: #8c222c;
            --hint-bg: #033C4A; --hint-text: #b6effb; --hint-border: #0f6674;
            --button-disabled-bg: #5a6268; --button-disabled-text: #adb5bd;
            --button-shuffle-bg: linear-gradient(135deg, #c4630e 0%, #b04e00 100%);
            --button-shuffle-hover: linear-gradient(135deg, #b04e00 0%, #934000 100%);
            --solved-color-0-bg: linear-gradient(135deg, #4d441e 0%, #443b19 100%);
            --solved-color-0-text: #fefae0; --solved-color-0-border: #8a6d3b;
            --solved-color-1-bg: linear-gradient(135deg, #004c75 0%, #003d5e 100%);
            --solved-color-1-text: #caf0f8; --solved-color-1-border: #006298;
            --solved-color-2-bg: linear-gradient(135deg, #1c4b33 0%, #153826 100%);
            --solved-color-2-text: #d8f3dc; --solved-color-2-border: #255a40;
            --solved-color-3-bg: linear-gradient(135deg, #8a1234 0%, #700f2b 100%);
            --solved-color-3-text: #fec8d8; --solved-color-3-border: #b01742;
            --word-item-base-bg: #3E444A; --word-item-base-border: #5A6268;
            --controls-bg: #343a40; --status-bar-bg: #343a40;
            --modal-overlay-bg: rgba(0, 0, 0, 0.8);
            --theme-toggle-btn-color: var(--text-secondary);
            --theme-toggle-btn-hover-color: var(--text-primary);
            --error-message-bg: var(--incorrect-bg); --error-message-text: var(--incorrect-text);
            --error-message-border: var(--incorrect-border);
            --timer-default-color: #79c0ff;
            --timer-warning-color: #ff848f;
            --daily-indicator-bg: color-mix(in srgb, var(--accent-primary) 30%, transparent);
            --daily-indicator-text: #79c0ff;
            --leaderboard-header-bg: #0b5ed7; /* Slightly darker blue for dark mode header */
            --leaderboard-header-text: #e9ecef;
            --leaderboard-row-even-bg: #3E444A;
            --leaderboard-border-color: #5A6268;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Poppins', sans-serif; line-height: 1.6;
            background: linear-gradient(to bottom, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-primary); padding: 20px; min-height: 100vh;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; animation: fadeInPage 0.5s ease-out forwards;
            transition: background var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        @keyframes fadeInPage { to { opacity: 1; } }
        body.fade-out { opacity: 1; animation: fadeOutPage 0.3s ease-in forwards; }
        @keyframes fadeOutPage { to { opacity: 0; } }
        .container {
            width: 100%; max-width: 700px; margin: 20px auto;
            background: var(--container-bg); padding: 30px;
            border-radius: 16px; box-shadow: var(--shadow-lg);
            position: relative;
            transition: background-color var(--transition-speed) ease;
        }
        #theme-toggle-btn {
            position: absolute; top: 15px; right: 15px;
            background: none; border: none; font-size: 1.3em; cursor: pointer;
            color: var(--theme-toggle-btn-color); padding: 5px;
            transition: color var(--transition-speed) ease, transform var(--transition-speed) ease;
        }
        #theme-toggle-btn:hover { color: var(--theme-toggle-btn-hover-color); transform: scale(1.1); }
        h1 { text-align: center; color: var(--text-primary); margin-bottom: 5px; font-weight: 700; transition: color var(--transition-speed) ease;}
        .daily-challenge-indicator {
            text-align: center; font-weight: bold; color: var(--daily-indicator-text);
            background-color: var(--daily-indicator-bg);
            padding: 5px 10px; margin-bottom: 10px; margin-top: 5px; border-radius: 6px;
            font-size: 0.9em;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        h2 { text-align: center; color: var(--text-secondary); margin-bottom: 15px; font-weight: 600; font-size: 1em; transition: color var(--transition-speed) ease;}
        .status-bar {
            display: flex; justify-content: space-around; align-items: center;
            padding: 15px 0; margin-bottom: 20px; border-bottom: 1px solid var(--word-item-base-border);
            flex-wrap: wrap; gap: 15px; background-color: var(--status-bar-bg);
            border-radius: 8px; box-shadow: var(--shadow-sm);
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .status-bar div {
            font-weight: 600; font-size: 0.9em; text-align: center;
            flex-basis: auto; flex-grow: 1; color: var(--text-secondary);
            transition: color var(--transition-speed) ease;
        }
        .status-bar span {
            font-weight: 700; color: var(--accent-primary);
            font-size: 1.1em; margin-left: 5px;
            transition: color var(--transition-speed) ease;
        }
        #timer-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #timer {
            min-width: 80px;
            color: var(--timer-default-color);
            transition: color 0.3s ease;
        }
        #timer.countdown-active { font-weight: bold; }
        #timer.countdown-warning { color: var(--timer-warning-color) !important; animation: pulseWarning 1s infinite alternate; }
        @keyframes pulseWarning { from { transform: scale(1); } to { transform: scale(1.05); } }

        #word-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 25px; }
        .word-item {
            background-color: var(--word-item-base-bg); padding: 15px 8px; text-align: center;
            border-radius: 8px; cursor: pointer; font-weight: 600; text-transform: uppercase;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease,
                        transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            user-select: none; min-height: 3.5em; display: flex;
            align-items: center; justify-content: center; line-height: 1.2;
            word-break: break-word; box-shadow: var(--shadow-sm); border: 1px solid var(--word-item-base-border);
            color: var(--text-primary);
        }
        .word-item:hover:not(.selected):not(.solved):not(.disabled) {
             background-color: var(--accent-secondary); color: var(--selected-text);
             transform: translateY(-3px); box-shadow: var(--shadow-md);
        }
        html.dark-theme .word-item:hover:not(.selected):not(.solved):not(.disabled) { background-color: #5f67ee; }
        .word-item:focus-visible, .solved-group.reviewable:focus-visible {
            outline: 3px solid var(--accent-primary); outline-offset: 2px; box-shadow: var(--shadow-md);
        }
        .word-item.selected {
            background: var(--selected-bg); color: var(--selected-text);
            transform: scale(1.05) translateY(-2px); box-shadow: var(--shadow-md); border: none;
        }
        .word-item.solved,
        .word-item.disabled {
            background-color: var(--solved-bg); color: var(--solved-text);
            cursor: default; opacity: var(--disabled-opacity); box-shadow: none;
            border: 1px solid var(--solved-text); transform: none;
        }
        .word-item.correct-match-animation { animation: correctMatchPop 0.6s ease-out forwards; }
        @keyframes correctMatchPop {
            0% { transform: scale(1.05) translateY(-2px); opacity: 1; }
            50% { transform: scale(1.2) translateY(-5px) rotate(3deg); opacity: 0.9; background-color: var(--correct-bg); color: var(--correct-text); }
            100% { transform: scale(1); opacity: 1; }
        }
        .controls {
            text-align: center; margin-bottom: 20px; display: grid;
            grid-template-columns: 1fr auto auto auto;
            align-items: center;
            gap: 10px; padding: 15px; background-color: var(--controls-bg);
            border-radius: 8px; box-shadow: var(--shadow-sm);
            transition: background-color var(--transition-speed) ease;
        }
        .controls p {
            margin: 0; white-space: nowrap; font-size: 0.9em;
            color: var(--text-secondary); text-align: left;
            transition: color var(--transition-speed) ease;
            grid-column: 1 / 2;
        }
        .controls p span { font-weight: 700; color: var(--accent-primary); font-size: 1.1em; transition: color var(--transition-speed) ease;}
        .controls button, .post-game-actions button {
            padding: 10px 18px;
            cursor: pointer; border-radius: 25px;
            border: none; font-weight: 600; font-size: 0.85em;
            color: white;
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm);
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        }
        .controls button:hover:not(:disabled), .post-game-actions button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-md); }
        .controls button:active:not(:disabled), .post-game-actions button:active:not(:disabled) { transform: translateY(0); box-shadow: var(--shadow-sm); }

        #clear-selection-btn { background: var(--button-warning-bg); }
        #clear-selection-btn:hover:not(:disabled) { background: var(--button-warning-hover); }
        #hint-btn { background: var(--button-info-bg); }
        #hint-btn:hover:not(:disabled) { background: var(--button-info-hover); }
        #shuffle-btn { background: var(--button-shuffle-bg); }
        #shuffle-btn:hover:not(:disabled) { background: var(--button-shuffle-hover); }

        .controls button:disabled, .post-game-actions button:disabled {
            background: var(--button-disabled-bg); color: var(--button-disabled-text);
            cursor: not-allowed; box-shadow: none; transform: none;
        }
        #feedback-area {
            margin-top: 15px; margin-bottom: 20px; padding: 15px 20px;
            border-radius: 8px; min-height: 3em; text-align: center; font-weight: 600;
            box-sizing: border-box; display: flex; align-items: center; justify-content: center;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            border: 1px solid transparent;
        }
        .feedback-correct { background-color: var(--correct-bg); color: var(--correct-text); border-color: var(--correct-border); }
        .feedback-incorrect { background-color: var(--incorrect-bg); color: var(--incorrect-text); border-color: var(--incorrect-border); }
        .feedback-hint { background-color: var(--hint-bg); color: var(--hint-text); border-color: var(--hint-border); }
        #solved-groups-area { margin-bottom: 25px; display: grid; grid-template-columns: 1fr; gap: 15px; }
        .solved-group {
            border-radius: 12px; padding: 15px 20px; text-align: center;
            box-shadow: var(--shadow-md); border-width: 2px; border-style: solid;
            transition: transform 0.3s ease-out, opacity 0.5s ease-out, background var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            transform: scale(0.95); opacity: 0; animation: fadeInScale 0.5s ease-out forwards;
        }
        @keyframes fadeInScale { to { opacity: 1; transform: scale(1); } }
        .solved-group.reviewable { cursor: pointer; }
        .solved-group.reviewable:hover { box-shadow: var(--shadow-lg); transform: scale(1.02); }
        .solved-group strong { display: block; margin-bottom: 8px; text-transform: uppercase; font-size: 1em; font-weight: 700; }
        .solved-group p { margin: 0; font-size: 0.95em; font-weight: 400; line-height: 1.5; }
        .solved-group-color-0 { background: var(--solved-color-0-bg); color: var(--solved-color-0-text); border-color: var(--solved-color-0-border); animation-delay: 0s; }
        .solved-group-color-1 { background: var(--solved-color-1-bg); color: var(--solved-color-1-text); border-color: var(--solved-color-1-border); animation-delay: 0.1s; }
        .solved-group-color-2 { background: var(--solved-color-2-bg); color: var(--solved-color-2-text); border-color: var(--solved-color-2-border); animation-delay: 0.2s; }
        .solved-group-color-3 { background: var(--solved-color-3-bg); color: var(--solved-color-3-text); border-color: var(--solved-color-3-border); animation-delay: 0.3s; }
        .word-item.highlight-review {
            background-color: var(--hint-bg) !important; color: var(--hint-text) !important;
            border: 2px solid var(--hint-border) !important; opacity: 1 !important; transform: scale(1.03);
            transition: background-color 0.1s ease-out, color 0.1s ease-out, border-color 0.1s ease-out, transform 0.1s ease-out;
        }
        .word-item.highlight-hint {
            outline: 3px dashed var(--accent-secondary); outline-offset: 2px;
            transition: outline 0.2s ease-out; position: relative; z-index: 5;
        }
        .post-game-actions {
            margin-top: 25px;
            display: flex; /* Use flex for better alignment and spacing */
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center; /* Center buttons */
            gap: 10px; /* Space between buttons */
        }
        .post-game-actions button {
             flex-grow: 1; /* Allow buttons to grow and fill space */
             min-width: 180px; /* Minimum width for buttons */
        }

        #new-game-btn { background: var(--button-success-bg); }
        #new-game-btn:hover:not(:disabled) { background: var(--button-success-hover); }
        #view-solution-btn { background: var(--button-info-bg); }
        #view-solution-btn:hover:not(:disabled) { background: var(--button-info-hover); }
        #view-leaderboard-btn { background: var(--button-primary-bg); } /* Example style */
        #view-leaderboard-btn:hover:not(:disabled) { background: var(--button-primary-hover); }

        .error-message {
             text-align: center; color: var(--error-message-text); font-style: normal;
             background-color: var(--error-message-bg); border: 1px solid var(--error-message-border);
             padding: 10px 15px; border-radius: 8px; font-weight: 600; margin-top: 15px; margin-bottom: 20px;
             transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        #loading-message, #puzzle-info {
             text-align: center; color: var(--text-secondary);
             font-style: italic; margin-bottom: 15px;
             transition: color var(--transition-speed) ease;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0) scale(1.05) translateY(-2px); }
            20% { transform: translateX(-7px) scale(1.05) translateY(-2px) rotate(-2deg); }
            40% { transform: translateX(7px) scale(1.05) translateY(-2px) rotate(2deg); }
            60% { transform: translateX(-5px) scale(1.05) translateY(-2px) rotate(-1deg); }
            80% { transform: translateX(5px) scale(1.05) translateY(-2px) rotate(1deg); }
        }
        .modal-overlay {
            position: fixed; inset: 0; background-color: var(--modal-overlay-bg);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s, background-color var(--transition-speed) ease;
        }
        .modal-overlay.modal-open { opacity: 1; visibility: visible; }
        .modal-content {
            background: var(--container-bg); padding: 30px 40px; border-radius: 15px;
            border: 1px solid var(--container-border); box-shadow: var(--shadow-lg);
            backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity));
            max-width: 450px; width: 90%; text-align: center; color: var(--text-primary);
            transform: scale(0.9);
            transition: transform 0.3s ease, background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .modal-overlay.modal-open .modal-content { transform: scale(1); }
        .modal-title {
            font-size: 1.5em; font-weight: 700; margin-bottom: 15px;
            display: flex; align-items: center; justify-content: center;
            gap: 10px; color: var(--accent-primary);
            transition: color var(--transition-speed) ease;
        }
        .modal-content p { margin-bottom: 25px; font-size: 1em; line-height: 1.6; color: var(--text-secondary); transition: color var(--transition-speed) ease;}
        .modal-actions { display: flex; justify-content: space-around; gap: 15px; flex-wrap: wrap; }
        .modal-button {
            padding: 10px 25px; cursor: pointer; border-radius: 25px;
            border: 1px solid transparent; font-weight: 600; font-size: 0.9em; color: #fff;
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm); display: flex; align-items: center; gap: 8px;
        }
        .modal-button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: var(--shadow-md); }
        .modal-button:focus-visible { outline: 3px solid var(--accent-primary); outline-offset: 1px; }
        .modal-button-confirm { background: var(--button-success-bg); }
        .modal-button-confirm:hover:not(:disabled) { background: var(--button-success-hover); }
        .modal-button-cancel { background: var(--button-warning-bg); color: var(--text-primary); }
        html.dark-theme .modal-button-cancel { color: var(--text-primary); }
        .modal-button-cancel:hover:not(:disabled) { background: var(--button-warning-hover); }
        .modal-button i { font-size: 1.1em; }

        /* Style for player name input in modal */
        #player-name-input {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc; /* Light theme border */
            width: 80%;
            margin-bottom: 20px;
            font-size: 1em;
            background-color: var(--word-item-base-bg); /* Use theme variable */
            color: var(--text-primary); /* Use theme variable */
        }
        html.dark-theme #player-name-input {
            border: 1px solid #555; /* Dark theme border */
        }

        /* Leaderboard Modal Specific Styles */
        #leaderboard-modal .modal-content {
            max-width: 650px; /* Wider for table */
        }
        #leaderboard-modal .filters {
            margin-bottom: 15px;
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        #leaderboard-modal .filters label {
            margin-right: 5px;
            color: var(--text-secondary);
        }
        #leaderboard-modal .filters select,
        #leaderboard-modal .filters button {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--word-item-base-border);
            background-color: var(--word-item-base-bg);
            color: var(--text-primary);
            font-size: 0.9em;
        }
        #leaderboard-modal #lb-filter-btn {
            background: var(--button-info-bg);
            color: white;
            padding: 8px 15px; /* Adjusted padding */
        }
        #leaderboard-modal #lb-filter-btn:hover:not(:disabled) {
            background: var(--button-info-hover);
        }
        #leaderboard-modal table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px; /* Reduced margin */
        }
        #leaderboard-modal th, #leaderboard-modal td {
            border: 1px solid var(--leaderboard-border-color);
            padding: 8px 10px;
            text-align: left;
            font-size: 0.9em;
        }
        #leaderboard-modal th {
            background-color: var(--leaderboard-header-bg);
            color: var(--leaderboard-header-text);
            font-weight: 600;
        }
        #leaderboard-modal tr:nth-child(even) {
            background-color: var(--leaderboard-row-even-bg);
        }
        #lb-no-scores-message {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 15px;
        }


        @media (max-width: 480px) {
            .modal-content { padding: 20px 25px; } .modal-title { font-size: 1.3em; }
            .modal-actions { flex-direction: column; align-items: center; }
            .modal-button { width: 80%; justify-content: center; }
        }
        @media (max-width: 768px) {
            .container { padding: 20px; } #theme-toggle-btn { top: 10px; right: 10px; }
            h1 { font-size: 1.8em; }
            .status-bar { padding: 10px; } .status-bar div { font-size: 0.85em; } .status-bar span { font-size: 1em; }
            #word-grid { gap: 10px; } .word-item { font-size: 0.9em; min-height: 3.2em; padding: 12px 5px; }
            .controls { grid-template-columns: 1fr; justify-items: center; }
            .controls p { text-align: center; margin-bottom: 10px; grid-column: 1 / -1; }
            .controls button { width: 60%; }
            .controls #shuffle-btn { width: 60%; }
            /* .post-game-actions button { width: 70%;} */ /* Adjusted by flex properties */
            #leaderboard-modal .modal-content { max-width: 95%; padding: 15px; }
            #leaderboard-modal .filters { flex-direction: column; gap: 8px; }
            #leaderboard-modal .filters select, #leaderboard-modal .filters button { width: 100%; margin-right: 0; }
            #leaderboard-modal th, #leaderboard-modal td { font-size: 0.8em; padding: 6px 8px; }

        }
        @media (max-width: 480px) {
            body { padding: 10px; } .container { padding: 15px; border-radius: 12px; }
            h1 { font-size: 1.5em; margin-bottom: 10px;} h2 { font-size: 1em; margin-bottom: 15px; }
            .status-bar { flex-direction: column; align-items: stretch; gap: 8px; padding: 8px; }
            .status-bar div { text-align: left; padding: 0 10px; }
            #word-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 20px;}
            .word-item { font-size: 0.85em; min-height: 3.5em; font-weight: 600; }
            .controls { grid-template-columns: 1fr 1fr; grid-template-areas: "text text" "b1 b2" "b3 b3"; gap: 8px; }
            .controls p { grid-area: text; margin-bottom: 5px;}
            .controls #shuffle-btn { grid-area: b1; width: 100%; }
            .controls #clear-selection-btn { grid-area: b2; width: 100%;}
            .controls #hint-btn { grid-area: b3; width: 100%; justify-self: center;}
            .post-game-actions button { width: 85%; min-width: unset; } /* Override min-width for small screens */
            #feedback-area { padding: 10px 15px; font-size: 0.9em;}
            .solved-group { padding: 10px 15px; } .solved-group strong { font-size: 0.9em; } .solved-group p { font-size: 0.9em; }
            #leaderboard-modal th, #leaderboard-modal td { font-size: 0.75em; padding: 4px 5px; word-break: break-all; }
        }
    </style>
</head>
<body>
    <!-- Sound effect elements -->
    <audio id="select-sound" src="/static/sounds/select.mp3" preload="auto"></audio>
    <audio id="correct-sound" src="/static/sounds/correct.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="/static/sounds/incorrect.mp3" preload="auto"></audio>
    <audio id="win-sound" src="/static/sounds/win.mp3" preload="auto"></audio>
    <audio id="lose-sound" src="/static/sounds/lose.mp3" preload="auto"></audio>
    <audio id="shuffle-sound" src="/static/sounds/shuffle.mp3" preload="auto"></audio>


    <div class="container game-container">
        <button id="theme-toggle-btn" aria-label="Toggle dark mode">
            <i class="fas fa-moon"></i>
        </button>

        <h1>WordLinks</h1>
        <div id="daily-challenge-indicator" class="daily-challenge-indicator" style="display: none;">
            ðŸŒŸ Daily Challenge ðŸŒŸ
        </div>
        <div class="status-bar">
            <div id="timer-container">
                <span id="timer-label">Time: </span><span id="timer">00:00</span>
            </div>
            <div>Score: <span id="score">1000</span></div>
            <div>Hints: <span id="hints-used">0</span> / <span id="hints-allowed">3</span></div>
            <div>Mistakes: <span id="lives-remaining">4</span></div>
        </div>

        <p id="loading-message">Loading puzzle...</p>
        <p id="error-message" class="error-message" style="display: none;"></p>
        <div id="puzzle-info"></div>

        <div id="solved-groups-area"></div>
        <div id="word-grid" role="grid"></div>

        <div class="controls">
             <p>Selected: <span id="selected-count">0</span> / 4</p>
             <button id="shuffle-btn"><i class="fas fa-random"></i> Shuffle</button>
             <button id="clear-selection-btn" disabled><i class="fas fa-times-circle"></i> Clear</button>
             <button id="hint-btn"><i class="fas fa-lightbulb"></i> Hint</button>
        </div>

        <div id="feedback-area" aria-live="polite" aria-atomic="true"></div>

        <div class="post-game-actions" style="display: none;">
            <button id="view-leaderboard-btn"> <!-- NEW BUTTON -->
                <i class="fas fa-trophy"></i> Leaderboard
            </button>
            <button id="view-solution-btn">
                <i class="fas fa-eye"></i> View Solution
            </button>
            <button id="new-game-btn">
                <i class="fas fa-redo"></i> Play Again?
            </button>
        </div>

        <!-- Show Answer Modal (Hints Exhausted) -->
        <div id="show-answer-modal" class="modal-overlay" style="display: none;" role="dialog" aria-labelledby="show-answer-modal-title" aria-modal="true">
            <div class="modal-content">
                <h3 id="show-answer-modal-title" class="modal-title"><i class="fas fa-eye"></i> Hints Exhausted</h3>
                <p>You've used all available hints. Would you like to reveal the solution?</p>
                <div class="modal-actions">
                    <button id="confirm-show-answer-btn" class="modal-button modal-button-confirm">
                        <i class="fas fa-check"></i> Show Answer
                    </button>
                    <button id="cancel-show-answer-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Keep Playing
                    </button>
                </div>
            </div>
        </div>

        <!-- Submit Score Modal -->
        <div id="score-submit-modal" class="modal-overlay" style="display: none;" role="dialog" aria-labelledby="score-submit-modal-title" aria-modal="true">
            <div class="modal-content">
                <h3 id="score-submit-modal-title" class="modal-title"><i class="fas fa-trophy"></i> Submit Your Score!</h3>
                <p>Congratulations! Your final score is <strong id="modal-final-score"></strong>.</p>
                <p>Enter your name for the leaderboard (3-10 characters):</p>
                <input type="text" id="player-name-input" maxlength="10" minlength="3" placeholder="Your Name">
                <div class="modal-actions">
                    <button id="confirm-submit-score-btn" class="modal-button modal-button-confirm">
                        <i class="fas fa-check"></i> Submit Score
                    </button>
                    <button id="cancel-submit-score-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Maybe Later
                    </button>
                </div>
            </div>
        </div>

        <!-- Leaderboard Modal (NEW) -->
        <div id="leaderboard-modal" class="modal-overlay" style="display: none;" role="dialog" aria-labelledby="leaderboard-modal-title" aria-modal="true">
            <div class="modal-content"> <!-- Removed inline max-width, using CSS class now -->
                <h3 id="leaderboard-modal-title" class="modal-title"><i class="fas fa-list-ol"></i> Leaderboard</h3>
                <div class="filters">
                    <label for="lb-difficulty-filter">Difficulty:</label>
                    <select id="lb-difficulty-filter">
                        <option value="">All</option>
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                        <option value="Daily Challenge">Daily Challenge</option>
                    </select>
                    <label for="lb-mode-filter">Mode:</label>
                    <select id="lb-mode-filter">
                        <option value="classic">Classic</option>
                        <!-- Add other game modes if you have them -->
                    </select>
                    <button id="lb-filter-btn" class="modal-button">
                        <i class="fas fa-filter"></i> Filter
                    </button>
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Player</th>
                                <th>Score</th>
                                <th>Time (s)</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboard-modal-body">
                            <!-- Scores will be populated here -->
                        </tbody>
                    </table>
                </div>
                <p id="lb-no-scores-message" style="display: none;">No scores found for the selected filters.</p>
                <div class="modal-actions" style="margin-top: 20px;">
                    <button id="close-leaderboard-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Close
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const wordGrid = document.getElementById('word-grid');
            const loadingMessage = document.getElementById('loading-message');
            const errorMessage = document.getElementById('error-message');
            const selectedCountSpan = document.getElementById('selected-count');
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            const feedbackArea = document.getElementById('feedback-area');
            const solvedGroupsArea = document.getElementById('solved-groups-area');
            const livesRemainingSpan = document.getElementById('lives-remaining');
            const puzzleInfoDiv = document.getElementById('puzzle-info');
            const timerSpan = document.getElementById('timer');
            const timerLabelSpan = document.getElementById('timer-label');
            const scoreSpan = document.getElementById('score');
            const hintBtn = document.getElementById('hint-btn');
            const shuffleBtn = document.getElementById('shuffle-btn');
            const hintsUsedSpan = document.getElementById('hints-used');
            const hintsAllowedSpan = document.getElementById('hints-allowed');
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const dailyChallengeIndicator = document.getElementById('daily-challenge-indicator');

            // Modals and their controls
            const showAnswerModal = document.getElementById('show-answer-modal');
            const confirmShowAnswerBtn = document.getElementById('confirm-show-answer-btn');
            const cancelShowAnswerBtn = document.getElementById('cancel-show-answer-btn');

            const scoreSubmitModal = document.getElementById('score-submit-modal');
            const confirmSubmitScoreBtn = document.getElementById('confirm-submit-score-btn');
            const cancelSubmitScoreBtn = document.getElementById('cancel-submit-score-btn');
            const modalFinalScoreSpan = document.getElementById('modal-final-score');
            const playerNameInput = document.getElementById('player-name-input');

            const viewLeaderboardBtn = document.getElementById('view-leaderboard-btn'); // NEW
            const leaderboardModal = document.getElementById('leaderboard-modal');     // NEW
            const leaderboardModalBody = document.getElementById('leaderboard-modal-body'); // NEW
            const closeLeaderboardBtn = document.getElementById('close-leaderboard-btn'); // NEW
            const lbDifficultyFilter = document.getElementById('lb-difficulty-filter'); // NEW
            const lbModeFilter = document.getElementById('lb-mode-filter');             // NEW
            const lbFilterBtn = document.getElementById('lb-filter-btn');               // NEW
            const lbNoScoresMessage = document.getElementById('lb-no-scores-message');   // NEW


            const postGameActionsDiv = document.querySelector('.post-game-actions');
            const viewSolutionBtn = document.getElementById('view-solution-btn');
            const newGameBtn = document.getElementById('new-game-btn');


            const selectSound = document.getElementById('select-sound');
            const correctSound = document.getElementById('correct-sound');
            const incorrectSound = document.getElementById('incorrect-sound');
            const winSound = document.getElementById('win-sound');
            const loseSound = document.getElementById('lose-sound');
            const shuffleSound = document.getElementById('shuffle-sound');

            const STARTING_LIVES = 4;
            const STARTING_SCORE = 1000;
            const INCORRECT_GUESS_PENALTY = 75;
            const HINT_PENALTY = 150;
            const MAX_HINTS = 3;
            const PUZZLE_STORAGE_KEY = 'currentPuzzle';
            const STATS_STORAGE_KEY = 'wordLinksGameStats';
            const THEME_STORAGE_KEY = 'wordLinksTheme';
            const SHUFFLE_PENALTY_SCORE = 25;
            const MAX_SHUFFLES_ALLOWED = 3;

            const POINTS_PER_CORRECT_GROUP = 200;
            const TIME_BONUS_TARGET_SECONDS = 180;
            const TIME_BONUS_PER_SECOND_SAVED = 2;
            const GROUP_STREAK_THRESHOLD = 2;
            const GROUP_STREAK_BONUS_MULTIPLIER = 50;
            const PUZZLE_STREAK_BONUS_PER_STREAK = 100;
            const COUNTDOWN_WIN_BONUS_PER_SECOND = 1;

            let currentPuzzle = null, selectedWords = [], lives = STARTING_LIVES, score = STARTING_SCORE;
            let hintsUsed = 0, revealedGroupsCount = 0, solvedGroupKeys = [], isSubmitting = false;
            let gameActive = false, timerInterval = null, startTime = null, feedbackTimeout = null;
            let gameStats = { wins: 0, losses: 0, currentStreak: 0, maxStreak: 0, fastestTime: null, perfectWins: 0, performance: { easy: { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 }, medium: { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 }, hard: { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 }}};
            let hintHighlightTimeout = null, elementToFocusOnModalClose = null;
            let modalFocusableElements = [], currentOpenModal = null;
            const sunIconClass = 'fa-sun', moonIconClass = 'fa-moon';
            let currentGroupStreak = 0;
            let gameMode = "classic";
            let countdownDuration = 0;
            let timeLeft = 0;
            let isDailyChallenge = false;
            let shufflesUsed = 0;

            function playSound(soundElement) {
                if (soundElement && typeof soundElement.play === 'function') {
                    if (soundElement.readyState >= 2 || !soundElement.error) {
                        soundElement.currentTime = 0;
                        soundElement.play().catch(error => console.warn("Audio play failed:", soundElement.id, error));
                    } else if (soundElement.error) {
                         console.warn("Cannot play sound, media error:", soundElement.id, soundElement.error);
                    } else {
                         console.warn("Cannot play sound, not enough data or error:", soundElement.id, "ReadyState:", soundElement.readyState);
                    }
                } else if (soundElement) {
                    console.warn("Attempted to play sound on a non-playable audio element:", soundElement.id);
                }
            }

            function initGame() {
                closeModal(showAnswerModal); // Use generic close
                closeModal(scoreSubmitModal);
                closeModal(leaderboardModal); // Close leaderboard on init
                stopTimer(); gameActive = false;
                loadStats();

                isDailyChallenge = sessionStorage.getItem('isDailyChallenge') === 'true';
                if (isDailyChallenge) {
                    gameMode = "classic";
                    if (dailyChallengeIndicator) dailyChallengeIndicator.style.display = 'block';
                } else {
                    if (dailyChallengeIndicator) dailyChallengeIndicator.style.display = 'none';
                    gameMode = sessionStorage.getItem('gameMode') || "classic";
                }

                if (gameMode === "countdown" && !isDailyChallenge) {
                    countdownDuration = parseInt(sessionStorage.getItem('countdownDuration'), 10) || 180;
                    timeLeft = countdownDuration;
                    if(timerLabelSpan) timerLabelSpan.textContent = "Time Left: ";
                    if(timerSpan) {
                        timerSpan.classList.add('countdown-active');
                        timerSpan.classList.remove('countdown-warning');
                        timerSpan.style.color = '';
                    }
                } else {
                    if(timerLabelSpan) timerLabelSpan.textContent = "Time: ";
                    if(timerSpan) {
                        timerSpan.classList.remove('countdown-active', 'countdown-warning');
                        timerSpan.style.color = '';
                    }
                }

                score = STARTING_SCORE;
                if (gameStats.currentStreak > 0 && gameMode === "classic" && !isDailyChallenge) {
                    const puzzleStreakBonus = gameStats.currentStreak * PUZZLE_STREAK_BONUS_PER_STREAK;
                    score += puzzleStreakBonus;
                }

                const puzzleDataString = sessionStorage.getItem(PUZZLE_STORAGE_KEY);
                if (!puzzleDataString) {
                    showError('No puzzle data found. Start new game.');
                    if(loadingMessage) loadingMessage.style.display = 'none';
                    disableAllInteraction();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'flex';
                    if (viewSolutionBtn) viewSolutionBtn.style.display = 'none';
                    if (newGameBtn) { newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome; }
                    return;
                }
                try {
                    currentPuzzle = JSON.parse(puzzleDataString);
                    if (!currentPuzzle || !currentPuzzle.words || !currentPuzzle.puzzle_id) throw new Error("Invalid puzzle data format.");
                    lives = STARTING_LIVES; hintsUsed = 0;
                    selectedWords = []; solvedGroupKeys = []; revealedGroupsCount = 0; isSubmitting = false;
                    currentGroupStreak = 0;
                    shufflesUsed = 0;

                    if(clearFeedback) clearFeedback();
                    if(solvedGroupsArea) solvedGroupsArea.innerHTML = '';
                    if(errorMessage) { errorMessage.style.display = 'none'; errorMessage.textContent = ''; }
                    if(loadingMessage) loadingMessage.style.display = 'none';
                    if(wordGrid) wordGrid.innerHTML = '';

                    if (puzzleInfoDiv) {
                        puzzleInfoDiv.innerHTML = '';
                        if (!isDailyChallenge && (currentPuzzle.difficulty || (currentPuzzle.puzzle_id && !currentPuzzle.puzzle_id.startsWith("daily_")))) {
                             const infoP = document.createElement('p'); let infoText = [];
                             if(currentPuzzle.puzzle_id && !currentPuzzle.puzzle_id.startsWith("daily_")) infoText.push(`Puzzle #${currentPuzzle.puzzle_id}`);
                             if(currentPuzzle.difficulty) infoText.push(`Difficulty: ${currentPuzzle.difficulty}`);
                             if(infoText.length > 0) infoP.textContent = infoText.join(' | ');
                             puzzleInfoDiv.appendChild(infoP);
                        }
                    }

                    displayWords(currentPuzzle.words);
                    updateScoreDisplay(); updateLivesDisplay(); updateHintsDisplay(); updateSelectionUI();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'none';
                    enableAllInteraction(); startTime = Date.now();
                    startTimer();
                    gameActive = true;
                    setInitialFocus();
                } catch (error) {
                    console.error("Error initializing game:", error);
                    showError(`Failed to load puzzle: ${error.message}. Start new game.`);
                    if(loadingMessage) loadingMessage.style.display = 'none'; disableAllInteraction();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'flex';
                    if (viewSolutionBtn) viewSolutionBtn.style.display = 'none';
                    if (newGameBtn) { newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome; }
                }
            }

            function displayWords(words) {
                if(!wordGrid) return;
                wordGrid.innerHTML = '';
                const shuffledWords = [...words].sort(() => Math.random() - 0.5);
                shuffledWords.forEach((word) => {
                    const wordDiv = document.createElement('div'); wordDiv.classList.add('word-item');
                    wordDiv.textContent = word; wordDiv.dataset.word = word;
                    wordDiv.setAttribute('role', 'gridcell'); wordDiv.setAttribute('aria-selected', 'false');
                    wordDiv.addEventListener('click', handleWordClick); wordDiv.addEventListener('keydown', handleWordKeyDown);
                    wordGrid.appendChild(wordDiv);
                });
            }

            function updateSelectionUI() {
                if(selectedCountSpan) selectedCountSpan.textContent = selectedWords.length;
                if(clearSelectionBtn) clearSelectionBtn.disabled = selectedWords.length === 0 || isSubmitting || !gameActive;
                if(hintBtn) hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
                if (shuffleBtn) {
                    shuffleBtn.disabled = isSubmitting || !gameActive || revealedGroupsCount === 4 || lives <= 0 || shufflesUsed >= MAX_SHUFFLES_ALLOWED;
                }
            }
            function updateLivesDisplay() {
                 if(!livesRemainingSpan) return;
                 livesRemainingSpan.textContent = lives; const livesDiv = livesRemainingSpan.closest('div');
                 if(livesDiv) {
                    livesDiv.style.color = lives <= 1 ? 'var(--timer-warning-color)' : 'var(--text-secondary)';
                    livesRemainingSpan.style.color = lives <= 1 ? 'var(--timer-warning-color)' : 'var(--accent-primary)';
                 }
            }
            function updateScoreDisplay() { if(scoreSpan) scoreSpan.textContent = Math.max(0, score); }
            function updateHintsDisplay() {
                 if(hintsUsedSpan) hintsUsedSpan.textContent = hintsUsed;
                 if(hintsAllowedSpan) hintsAllowedSpan.textContent = MAX_HINTS;
                 if(hintBtn) hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
            }

            function startTimer() {
                stopTimer();
                if (gameMode === "countdown") {
                    if(timerSpan) {
                        timerSpan.classList.add('countdown-active');
                        timerSpan.classList.remove('countdown-warning');
                        timerSpan.style.color = '';
                    }
                    timeLeft = countdownDuration;
                    updateTimerDisplay();

                    timerInterval = setInterval(() => {
                        if (!gameActive) return;
                        timeLeft--;
                        updateTimerDisplay();

                        if (timeLeft <= 10 && timeLeft > 0) {
                            if(timerSpan) timerSpan.classList.add('countdown-warning');
                        } else if (timeLeft <= 0) {
                            stopTimer();
                            showFeedback("Time's up! Puzzle failed.", 'feedback-incorrect', 0);
                            playSound(loseSound);
                            endGame(false);
                        }
                    }, 1000);
                } else {
                    if(timerSpan) {
                        timerSpan.classList.remove('countdown-active', 'countdown-warning');
                        timerSpan.style.color = '';
                    }
                    timerInterval = setInterval(() => {
                        if (!gameActive || !startTime) return;
                        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                        const minutes = Math.floor(elapsedSeconds / 60);
                        const seconds = elapsedSeconds % 60;
                        if(timerSpan) timerSpan.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    }, 1000);
                }
            }
            function updateTimerDisplay() {
                if (gameMode === "countdown" && timerSpan) {
                    const minutes = Math.floor(Math.max(0, timeLeft) / 60);
                    const seconds = Math.max(0, timeLeft) % 60;
                    timerSpan.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }
            function stopTimer() { clearInterval(timerInterval); timerInterval = null; }

            function handleWordClick(event) {
                 const wordDiv = event.currentTarget;
                 if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                 toggleWordSelection(wordDiv);
            }
            function handleWordKeyDown(event) {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault(); const wordDiv = event.currentTarget;
                    if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                    toggleWordSelection(wordDiv);
                }
            }
            function toggleWordSelection(wordDiv) {
                 const word = wordDiv.dataset.word; const isSelected = wordDiv.classList.contains('selected');
                 clearFeedback();
                 if (isSelected) {
                      selectedWords = selectedWords.filter(w => w !== word);
                      wordDiv.classList.remove('selected'); wordDiv.setAttribute('aria-selected', 'false');
                 } else {
                      if (selectedWords.length < 4) {
                           selectedWords.push(word); wordDiv.classList.add('selected');
                           wordDiv.setAttribute('aria-selected', 'true');
                           playSound(selectSound);
                      }
                 }
                 updateSelectionUI();
                 if (selectedWords.length === 4) setTimeout(submitGroupAttempt, 150);
            }
            function clearSelection() {
                 clearFeedback(); selectedWords = [];
                 document.querySelectorAll('.word-item.selected').forEach(el => {
                    el.classList.remove('selected'); el.setAttribute('aria-selected', 'false');
                 });
                 updateSelectionUI();
            }

            async function handleHintClick() {
                if (!gameActive || isSubmitting || hintsUsed >= MAX_HINTS || lives <= 0) return;
                isSubmitting = true; updateSelectionUI();
                score -= HINT_PENALTY; hintsUsed++;
                updateScoreDisplay(); updateHintsDisplay(); clearFeedback();
                try {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const response = await fetch('/api/get_hint', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ puzzle_id: currentPuzzle.puzzle_id, solved_group_keys: solvedGroupKeys }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: `HTTP error ${response.status}` }));
                        throw new Error(errorData.detail || `Hint Error: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.hint && result.words && Array.isArray(result.words)) {
                        showFeedback(result.hint, 'feedback-hint', 5000); highlightHintWords(result.words);
                        if (hintsUsed >= MAX_HINTS) { isSubmitting = false; updateSelectionUI(); setTimeout(() => openModal(showAnswerModal), 1000); } // Use generic open
                        else { isSubmitting = false; updateSelectionUI(); }
                    } else if (result.hint) {
                         showFeedback(result.hint, 'feedback-hint', hintsUsed >= MAX_HINTS ? 5000 : 4000);
                         if (hintsUsed >= MAX_HINTS) { isSubmitting = false; updateSelectionUI(); setTimeout(() => openModal(showAnswerModal), 1000); } // Use generic open
                         else { isSubmitting = false; updateSelectionUI(); }
                    } else {
                        showFeedback(result.message || "No hint available.", '', 3000);
                        if (hintsUsed > 0) { hintsUsed--; score += HINT_PENALTY; updateScoreDisplay(); updateHintsDisplay(); }
                        isSubmitting = false; updateSelectionUI();
                    }
                } catch (error) {
                    console.error('Error getting hint:', error);
                    showFeedback(`Hint Failed: ${error.message}`, 'feedback-incorrect', 4000);
                    let baseScore = STARTING_SCORE;
                    if (gameMode === "classic" && gameStats.currentStreak > 0 && !isDailyChallenge) {
                        baseScore += gameStats.currentStreak * PUZZLE_STREAK_BONUS_PER_STREAK;
                    }
                    if(hintsUsed > 0 && score + HINT_PENALTY <= baseScore + (MAX_HINTS * HINT_PENALTY) ) {
                         hintsUsed--; score += HINT_PENALTY;
                    }
                    updateScoreDisplay(); updateHintsDisplay(); isSubmitting = false; updateSelectionUI();
                }
            }
            function highlightHintWords(wordsArray) {
                if (hintHighlightTimeout) clearTimeout(hintHighlightTimeout);
                document.querySelectorAll('.word-item.highlight-hint').forEach(el => el.classList.remove('highlight-hint'));
                if (!wordsArray || wordsArray.length === 0 || !wordGrid) return;
                wordsArray.forEach(word => {
                    const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]:not(.solved)`);
                    if (wordDiv) wordDiv.classList.add('highlight-hint');
                });
                hintHighlightTimeout = setTimeout(() => {
                    document.querySelectorAll('.word-item.highlight-hint').forEach(el => el.classList.remove('highlight-hint'));
                    hintHighlightTimeout = null;
                }, 5000);
            }

            function clearFeedback() {
                if (feedbackTimeout) clearTimeout(feedbackTimeout); feedbackTimeout = null;
                if (feedbackArea) {
                    feedbackArea.textContent = ''; feedbackArea.className = '';
                    feedbackArea.classList.add('feedback-area');
                }
            }
            function showFeedback(message, className = '', duration = 3000) {
                 if (!feedbackArea) return; clearFeedback();
                 feedbackArea.textContent = message;
                 if (className) feedbackArea.classList.add(className);
                 if (duration > 0) {
                     feedbackTimeout = setTimeout(() => {
                         if (feedbackArea && feedbackArea.textContent === message) clearFeedback();
                     }, duration);
                 }
            }
            function showError(message) { if(errorMessage) {errorMessage.textContent = message; errorMessage.style.display = 'block';}}

            async function submitGroupAttempt() {
                if (!gameActive || isSubmitting || selectedWords.length !== 4 || lives <= 0) return;
                isSubmitting = true; updateSelectionUI(); clearFeedback(); showFeedback('Checking...', '', 0);
                const attemptPayload = { puzzle_id: currentPuzzle.puzzle_id, groups: { 'attempt': selectedWords } };
                await new Promise(resolve => setTimeout(resolve, 300));
                try {
                    const response = await fetch('/api/check_answer', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(attemptPayload)
                    });
                    if (!response.ok) {
                        let errorText = `Check Error: ${response.status}`;
                        try { const errorData = await response.json(); errorText = errorData.detail || errorText; } catch (e) {}
                        throw new Error(errorText);
                    }
                    const result = await response.json(); handleAttemptResult(result);
                } catch (error) {
                     console.error('Error submitting answer:', error);
                     showFeedback(`Failed to check answer: ${error.message}. Try again.`, 'feedback-incorrect', 4000);
                     clearSelection();
                } finally { isSubmitting = false; }
            }

            function handleAttemptResult(result) {
                 let foundCorrectGroup = false; let correctGroupDescription = "";
                 let newlySolvedKey = null; let difficultyIndex = revealedGroupsCount;
                 const currentResultSolvedKeys = Object.keys(result.solved_groups || {});
                 const justSolvedKeys = currentResultSolvedKeys.filter(key => !solvedGroupKeys.includes(key));

                 if (justSolvedKeys.length > 0) {
                     foundCorrectGroup = true; newlySolvedKey = justSolvedKeys[0];
                     const solvedGroupData = result.solved_groups[newlySolvedKey];
                      if (typeof solvedGroupData === 'object' && solvedGroupData !== null) {
                         correctGroupDescription = solvedGroupData.description || "Group Found";
                         difficultyIndex = solvedGroupData.difficulty_index !== undefined ? solvedGroupData.difficulty_index : revealedGroupsCount;
                      } else if (typeof solvedGroupData === 'string') { correctGroupDescription = solvedGroupData; }
                     if (!solvedGroupKeys.includes(newlySolvedKey)) solvedGroupKeys.push(newlySolvedKey);
                 }

                  if (foundCorrectGroup) {
                       playSound(correctSound);
                       score += POINTS_PER_CORRECT_GROUP;
                       currentGroupStreak++;

                       if (currentGroupStreak >= GROUP_STREAK_THRESHOLD) {
                           const groupStreakBonus = (currentGroupStreak - (GROUP_STREAK_THRESHOLD - 1)) * GROUP_STREAK_BONUS_MULTIPLIER;
                           score += groupStreakBonus;
                           showFeedback(`Correct! Group Streak: +${groupStreakBonus}pts!`, 'feedback-correct', 2000);
                       } else {
                           showFeedback(result.message || "Correct!", 'feedback-correct', 1500);
                       }
                       updateScoreDisplay();
                       const wordsInSolvedGroupForAnim = selectedWords.slice();
                       wordsInSolvedGroupForAnim.forEach(word => {
                           const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]`);
                           if (wordDiv) {
                               wordDiv.classList.add('correct-match-animation');
                               wordDiv.addEventListener('animationend', () => {
                                   wordDiv.classList.remove('correct-match-animation');
                               }, { once: true });
                           }
                       });
                       setTimeout(() => {
                           displaySolvedGroup(correctGroupDescription, wordsInSolvedGroupForAnim, difficultyIndex);
                           revealedGroupsCount++; selectedWords = []; updateSelectionUI();
                           if (revealedGroupsCount === 4) {
                                setTimeout(() => {
                                    showFeedback("Congratulations! Puzzle Solved!", 'feedback-correct', 0);
                                    playSound(winSound); endGame(true);
                                }, 300);
                           }
                       }, 600);
                  } else {
                       playSound(incorrectSound);
                       currentGroupStreak = 0;
                       score -= INCORRECT_GUESS_PENALTY;
                       lives--;
                       updateScoreDisplay(); updateLivesDisplay();
                       showFeedback(result.message || "Incorrect. Try again.", 'feedback-incorrect', 1800);
                       shakeWords();
                       if (lives <= 0) {
                            setTimeout(() => {
                                showFeedback("Game Over! You're out of mistakes.", 'feedback-incorrect', 0);
                                playSound(loseSound); endGame(false);
                            }, 600);
                       } else { setTimeout(clearSelection, 800); }
                  }
            }
            function displaySolvedGroup(description, wordsInGroup, colorIndex) {
                 if(!solvedGroupsArea || !wordGrid) return;
                 const groupDiv = document.createElement('div'); groupDiv.classList.add('solved-group');
                 const actualColorIndex = Math.min(Math.max(colorIndex, 0), 3);
                 groupDiv.classList.add(`solved-group-color-${actualColorIndex}`);
                 groupDiv.dataset.words = JSON.stringify(wordsInGroup);
                 const descStrong = document.createElement('strong'); descStrong.textContent = description; groupDiv.appendChild(descStrong);
                 const wordsP = document.createElement('p'); wordsP.textContent = wordsInGroup.sort().join(', '); groupDiv.appendChild(wordsP);
                 if (solvedGroupsArea.firstChild) solvedGroupsArea.insertBefore(groupDiv, solvedGroupsArea.firstChild);
                 else solvedGroupsArea.appendChild(groupDiv);
                 wordsInGroup.forEach(word => {
                       const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]`);
                       if (wordDiv) {
                            wordDiv.classList.add('solved'); wordDiv.classList.remove('selected', 'highlight-hint', 'correct-match-animation');
                            wordDiv.removeEventListener('click', handleWordClick); wordDiv.removeEventListener('keydown', handleWordKeyDown);
                            wordDiv.style.cursor = 'default'; wordDiv.setAttribute('aria-selected', 'false');
                            wordDiv.setAttribute('aria-disabled', 'true'); wordDiv.removeAttribute('tabindex');
                       }
                  });
                 reorderGrid();
            }
            function reorderGrid() {
                if(!wordGrid) return;
                const solvedItems = Array.from(wordGrid.querySelectorAll('.word-item.solved'));
                const activeItems = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved)'));
                wordGrid.innerHTML = '';
                activeItems.forEach(item => wordGrid.appendChild(item));
                solvedItems.forEach(item => wordGrid.appendChild(item));
            }
            function shakeWords() {
                 document.querySelectorAll('.word-item.selected').forEach(div => {
                      div.style.animation = 'none'; void div.offsetWidth;
                      div.style.animation = 'shake 0.5s ease-in-out';
                 });
            }

            function shuffleWordGrid() {
                if (!gameActive || isSubmitting || shufflesUsed >= MAX_SHUFFLES_ALLOWED) {
                    if (shufflesUsed >= MAX_SHUFFLES_ALLOWED) {
                        showFeedback("No more shuffles allowed.", "", 2000);
                    }
                    return;
                }
                if (selectedWords.length > 0) clearSelection();
                clearFeedback();

                const activeWordDivs = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved)'));
                const activeWordsData = activeWordDivs.map(div => div.dataset.word);
                activeWordsData.sort(() => Math.random() - 0.5);

                activeWordDivs.forEach((div, index) => {
                    div.textContent = activeWordsData[index];
                    div.dataset.word = activeWordsData[index];
                });

                shufflesUsed++;
                score -= SHUFFLE_PENALTY_SCORE;
                updateScoreDisplay();
                updateSelectionUI();

                playSound(shuffleSound);
                showFeedback(`Words shuffled! (${MAX_SHUFFLES_ALLOWED - shufflesUsed} left)`, "", 2000);
                setInitialFocus();
            }

            function endGame(isWin) {
                 if (!gameActive) return; gameActive = false;
                 stopTimer(); disableAllInteraction();
                 closeModal(showAnswerModal); // Use generic close
                 closeModal(scoreSubmitModal);
                 closeModal(leaderboardModal);


                 if (isWin) {
                    if (gameMode === "classic" && !isDailyChallenge) {
                        const now = Date.now();
                        const elapsedSeconds = startTime ? Math.floor((now - startTime) / 1000) : Infinity;
                        let timeBonus = 0;
                        if (elapsedSeconds < TIME_BONUS_TARGET_SECONDS) {
                            timeBonus = (TIME_BONUS_TARGET_SECONDS - elapsedSeconds) * TIME_BONUS_PER_SECOND_SAVED;
                            score += timeBonus;
                        }
                    } else if (gameMode === "countdown" && !isDailyChallenge) {
                        if (timeLeft > 0) {
                           score += timeLeft * COUNTDOWN_WIN_BONUS_PER_SECOND;
                        }
                    }
                 }
                 score = Math.max(0, score); updateScoreDisplay();

                 const endTime = Date.now();
                 const solveTimeSeconds = startTime ? Math.floor((endTime - startTime) / 1000) : null;

                 if (!isDailyChallenge && currentPuzzle && currentPuzzle.difficulty) {
                    const diffKey = currentPuzzle.difficulty.toLowerCase();
                    if (!gameStats.performance[diffKey]) {
                        gameStats.performance[diffKey] = { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 };
                    }
                    const perf = gameStats.performance[diffKey];
                    perf.plays = (perf.plays || 0) + 1;
                    perf.totalHints = (perf.totalHints || 0) + hintsUsed;
                    perf.totalMistakes = (perf.totalMistakes || 0) + (STARTING_LIVES - lives);
                    if (solveTimeSeconds !== null) {
                       perf.totalTime = (perf.totalTime || 0) + solveTimeSeconds;
                    }

                    if (isWin) {
                        perf.wins = (perf.wins || 0) + 1;
                        gameStats.wins++; gameStats.currentStreak++;
                        gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                        if (gameMode === "classic" && solveTimeSeconds !== null && (gameStats.fastestTime === null || solveTimeSeconds < gameStats.fastestTime)) {
                            gameStats.fastestTime = solveTimeSeconds;
                        }
                        if (hintsUsed === 0 && lives === STARTING_LIVES) {
                            gameStats.perfectWins = (gameStats.perfectWins || 0) + 1;
                        }
                    } else {
                        gameStats.losses++; gameStats.currentStreak = 0;
                    }
                    saveStats();
                 } else if (isWin && isDailyChallenge && currentPuzzle) {
                     console.info(`Daily challenge ${currentPuzzle.puzzle_id} completed successfully!`);
                 } else if (!isWin && !isDailyChallenge) {
                    gameStats.losses++; gameStats.currentStreak = 0;
                    saveStats();
                 }


                if (postGameActionsDiv) {
                    postGameActionsDiv.style.display = 'flex';
                }
                if (newGameBtn) {
                     newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome;
                }
                if (viewSolutionBtn) {
                    viewSolutionBtn.style.display = 'inline-flex';
                    viewSolutionBtn.disabled = false;
                    viewSolutionBtn.innerHTML = '<i class="fas fa-eye"></i> View Solution';
                    viewSolutionBtn.onclick = async () => {
                        viewSolutionBtn.disabled = true;
                        viewSolutionBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Revealing...';
                        await revealAllGroups();
                    };
                }
                 if (viewLeaderboardBtn) { // Enable leaderboard button post-game
                    viewLeaderboardBtn.style.display = 'inline-flex';
                }

                if (isWin && !isDailyChallenge && score > 0) {
                    openModal(scoreSubmitModal, playerNameInput);
                }
                addPostGameReviewListeners();
            }

            async function revealAllGroups() {
                if (!currentPuzzle?.puzzle_id) return;
                if (gameActive) { gameActive = false; stopTimer(); }
                clearFeedback(); showFeedback('Revealing solution...', '', 0);
                try {
                     await new Promise(resolve => setTimeout(resolve, 400));
                     const response = await fetch(`/api/get_solution/${currentPuzzle.puzzle_id}`);
                     if (!response.ok) throw new Error('Could not fetch solution from server.');
                     const solution = await response.json();
                     if (!solution || !solution.groups || typeof solution.groups !== 'object') {
                        throw new Error("Invalid solution format received from server.");
                     }
                     if(solvedGroupsArea) solvedGroupsArea.innerHTML = '';
                     if(wordGrid) wordGrid.querySelectorAll('.word-item').forEach(el => {
                          el.classList.remove('solved', 'disabled', 'selected', 'highlight-hint', 'highlight-review', 'correct-match-animation');
                          el.style.animation = '';
                     });
                     let colorIdx = 0;
                     for (const groupKey in solution.groups) {
                        if (Object.hasOwnProperty.call(solution.groups, groupKey)) {
                            const groupData = solution.groups[groupKey];
                            const groupDesc = groupData.description || "Group " + (colorIdx + 1);
                            const groupWords = groupData.words || [];
                            const groupColor = groupData.difficulty_index ?? colorIdx;
                            displaySolvedGroup(groupDesc, groupWords, groupColor);
                            colorIdx++;
                        }
                     }
                     reorderGrid(); clearFeedback(); showFeedback('Solution Revealed.', '', 3000);
                } catch (error) {
                    console.error("Failed to reveal solution:", error);
                    showFeedback(`Could not load the full solution: ${error.message}`, 'feedback-incorrect', 3000);
                } finally {
                    disableAllInteraction();
                    if (viewSolutionBtn && viewSolutionBtn.innerHTML.includes('Revealing...')) {
                         viewSolutionBtn.innerHTML = '<i class="fas fa-check"></i> Solution Shown';
                         viewSolutionBtn.disabled = true;
                    }
                    addPostGameReviewListeners();
                }
            }

            function disableAllInteraction() {
                 if(wordGrid) wordGrid.removeEventListener('keydown', actualGridNavigationHandler);
                 document.querySelectorAll('.word-item').forEach(el => {
                      el.removeEventListener('click', handleWordClick); el.removeEventListener('keydown', handleWordKeyDown);
                      el.style.cursor = 'default'; el.style.animation = '';
                      if (!el.classList.contains('solved')) {
                          el.classList.add('disabled'); el.classList.remove('selected');
                          el.setAttribute('aria-selected', 'false');
                      }
                     el.setAttribute('aria-disabled', 'true'); el.removeAttribute('tabindex');
                 });
                 if(clearSelectionBtn) clearSelectionBtn.disabled = true;
                 if(hintBtn) hintBtn.disabled = true;
                 if(shuffleBtn) shuffleBtn.disabled = true;
            }
            function enableAllInteraction() {
                 document.querySelectorAll('.word-item:not(.solved)').forEach(el => {
                     el.addEventListener('click', handleWordClick); el.addEventListener('keydown', handleWordKeyDown);
                     el.style.cursor = 'pointer'; el.classList.remove('disabled');
                     el.setAttribute('aria-disabled', 'false'); el.setAttribute('tabindex', '0');
                 });
                 updateSelectionUI(); setupGridNavigation();
            }
            function goToHome() {
                sessionStorage.removeItem(PUZZLE_STORAGE_KEY);
                sessionStorage.removeItem('gameMode');
                sessionStorage.removeItem('countdownDuration');
                sessionStorage.removeItem('isDailyChallenge');
                document.body.classList.add('fade-out');
                setTimeout(() => { window.location.href = '/home.html'; }, 300);
            }

            function loadStats() {
                const storedStats = localStorage.getItem(STATS_STORAGE_KEY);
                let defaultPerformanceSub = { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 };
                let defaultStats = {
                    wins: 0, losses: 0, currentStreak: 0, maxStreak: 0, fastestTime: null, perfectWins: 0,
                    performance: {
                        easy: { ...defaultPerformanceSub },
                        medium: { ...defaultPerformanceSub },
                        hard: { ...defaultPerformanceSub }
                    }
                };
                if (storedStats) {
                    try {
                        const parsedStats = JSON.parse(storedStats);
                        gameStats = {
                            ...defaultStats,
                            ...parsedStats,
                            performance: {
                                easy: { ...defaultPerformanceSub, ...(parsedStats.performance?.easy || {}) },
                                medium: { ...defaultPerformanceSub, ...(parsedStats.performance?.medium || {}) },
                                hard: { ...defaultPerformanceSub, ...(parsedStats.performance?.hard || {}) }
                            }
                        };
                    } catch (e) {
                        localStorage.removeItem(STATS_STORAGE_KEY);
                        gameStats = { ...defaultStats };
                        console.error("Error loading/parsing stats, resetting to default:", e);
                    }
                } else {
                    gameStats = { ...defaultStats };
                }
            }
            function saveStats() {
                try { localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(gameStats)); } catch (e) { console.error('Error saving stats:', e); }
            }
            function setInitialFocus() {
                const firstFocusableWord = wordGrid ? wordGrid.querySelector('.word-item:not(.solved):not(.disabled)') : null;
                if (firstFocusableWord) firstFocusableWord.focus();
                else if (newGameBtn && newGameBtn.style.display !== 'none') newGameBtn.focus();
                else if (hintBtn && !hintBtn.disabled) hintBtn.focus();
            }
            const actualGridNavigationHandler = (event) => {
                const { key } = event; const activeElement = document.activeElement;
                if (!activeElement || !activeElement.classList.contains('word-item') || !wordGrid || !wordGrid.contains(activeElement) || activeElement.classList.contains('solved') || activeElement.classList.contains('disabled')) return;
                if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) return;
                event.preventDefault();
                const focusableItems = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved):not(.disabled)'));
                if (focusableItems.length === 0) return;
                let currentIndex = focusableItems.indexOf(activeElement);
                if (currentIndex === -1) { if(focusableItems.length > 0) focusableItems[0].focus(); return; }
                const numCols = window.innerWidth <= 480 ? 2 : 4; let targetIndex = -1;
                switch (key) {
                    case 'ArrowUp':   targetIndex = currentIndex - numCols; break;
                    case 'ArrowDown': targetIndex = currentIndex + numCols; break;
                    case 'ArrowLeft': if (currentIndex % numCols !== 0) targetIndex = currentIndex - 1; break;
                    case 'ArrowRight': if ((currentIndex % numCols < numCols - 1) && currentIndex < focusableItems.length - 1) targetIndex = currentIndex + 1; break;
                }
                if (targetIndex >= 0 && targetIndex < focusableItems.length) focusableItems[targetIndex].focus();
            };
            function setupGridNavigation() {
                if(wordGrid) {
                    wordGrid.removeEventListener('keydown', actualGridNavigationHandler);
                    wordGrid.addEventListener('keydown', actualGridNavigationHandler);
                }
            }
            function addPostGameReviewListeners() {
                if(!solvedGroupsArea) return;
                const solvedGroupDivs = solvedGroupsArea.querySelectorAll('.solved-group');
                solvedGroupDivs.forEach(groupDiv => {
                    groupDiv.classList.add('reviewable'); groupDiv.setAttribute('tabindex', '0');
                    groupDiv.addEventListener('click', handleReviewGroupClick);
                    groupDiv.addEventListener('keydown', (event) => { if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); handleReviewGroupClick(event); }});
                });
            }
            function handleReviewGroupClick(event) {
                if(!wordGrid) return;
                const groupDiv = event.currentTarget; const wordsToHighlight = JSON.parse(groupDiv.dataset.words || '[]');
                wordGrid.querySelectorAll('.word-item.highlight-review').forEach(el => el.classList.remove('highlight-review'));
                wordsToHighlight.forEach(word => { const wordItem = wordGrid.querySelector(`.word-item.solved[data-word="${word}"]`); if (wordItem) wordItem.classList.add('highlight-review'); });
            }

            // --- Modal Handling Functions (Generic and Specific) ---
            function openModal(modalElement, focusElement = null) {
                if (modalElement) {
                    elementToFocusOnModalClose = document.activeElement;
                    currentOpenModal = modalElement;
                    modalElement.style.display = 'flex';
                    setTimeout(() => {
                        modalElement.classList.add('modal-open');
                        modalFocusableElements = Array.from(modalElement.querySelectorAll('button, input, [href], select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el => el && typeof el.focus === 'function' && el.offsetParent !== null);
                        if (focusElement && modalFocusableElements.includes(focusElement)) {
                            focusElement.focus();
                        } else if (modalFocusableElements.length > 0) {
                            modalFocusableElements[0].focus();
                        }
                        document.addEventListener('keydown', handleModalFocusTrap);
                    }, 10);
                }
            }

            function closeModal(modalElement) {
                if (modalElement && currentOpenModal === modalElement) {
                    document.removeEventListener('keydown', handleModalFocusTrap);
                    modalElement.classList.remove('modal-open');
                    currentOpenModal = null;
                    setTimeout(() => {
                        if (modalElement && !modalElement.classList.contains('modal-open')) modalElement.style.display = 'none';
                        if (elementToFocusOnModalClose && typeof elementToFocusOnModalClose.focus === 'function') {
                           try { elementToFocusOnModalClose.focus(); } catch(e) { console.warn("Failed to focus on previous element", e); }
                        }
                        elementToFocusOnModalClose = null;
                    }, 300);
                }
            }

            async function submitScore() {
                if (!playerNameInput || !currentPuzzle) return;
                const playerName = playerNameInput.value.trim();
                if (playerName.length < 3 || playerName.length > 10) {
                    showFeedback("Name must be 3-10 characters long.", "feedback-incorrect", 3000);
                    playerNameInput.focus();
                    return;
                }

                if(confirmSubmitScoreBtn) confirmSubmitScoreBtn.disabled = true;
                if(cancelSubmitScoreBtn) cancelSubmitScoreBtn.disabled = true;
                showFeedback("Submitting score...", "", 0);

                try {
                    const payload = {
                        player_name: playerName,
                        score: score,
                        puzzle_difficulty: currentPuzzle.difficulty || 'unknown', // Changed to puzzle_difficulty
                        time_taken: startTime ? Math.floor((Date.now() - startTime) / 1000) : null
                        // Add puzzle_id and game_mode if your backend /api/submit_score Pydantic model expects them
                        // puzzle_id: currentPuzzle ? currentPuzzle.puzzle_id : null,
                        // game_mode: gameMode // or a more specific value if needed
                    };
                    console.log("Submitting score with payload:", payload); // For debugging

                    const response = await fetch('/api/submit_score', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });

                    let responseDataText = await response.text(); // Get text first for debugging non-JSON responses
                    console.log("Score submission response status:", response.status);
                    console.log("Score submission response text:", responseDataText);

                    if (!response.ok) {
                        let serverErrorMessage = `Score submission failed: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = JSON.parse(responseDataText);
                            if (errorData && errorData.detail) {
                                if (typeof errorData.detail === 'string') {
                                    serverErrorMessage = errorData.detail;
                                } else if (Array.isArray(errorData.detail) && errorData.detail.length > 0 && errorData.detail[0].msg) {
                                    serverErrorMessage = errorData.detail.map(err => `${err.loc.join('.')} - ${err.msg}`).join('; ');
                                } else {
                                     serverErrorMessage = JSON.stringify(errorData);
                                }
                            } else if (errorData && errorData.message) {
                                serverErrorMessage = errorData.message;
                            }
                        } catch (e) { /* If response is not JSON, serverErrorMessage remains the default */ }
                        throw new Error(serverErrorMessage);
                    }
                    const result = JSON.parse(responseDataText); // If response.ok, expect JSON
                    showFeedback(result.message || "Score submitted successfully!", "feedback-correct", 3000);
                    closeModal(scoreSubmitModal);
                } catch (error) {
                    console.error('Error submitting score:', error);
                    showFeedback(`Score Submission Failed: ${error.message}`, 'feedback-incorrect', 4000);
                } finally {
                    if(confirmSubmitScoreBtn) confirmSubmitScoreBtn.disabled = false;
                    if(cancelSubmitScoreBtn) cancelSubmitScoreBtn.disabled = false;
                }
            }

            function openLeaderboardModal() {
                fetchLeaderboardData(lbDifficultyFilter.value || null, lbModeFilter.value);
                openModal(leaderboardModal, lbDifficultyFilter);
            }

            async function fetchLeaderboardData(difficulty = null, mode = 'classic') {
                if (!leaderboardModalBody || !lbNoScoresMessage) return;
                leaderboardModalBody.innerHTML = '<tr><td colspan="5" style="text-align:center;">Loading...</td></tr>';
                lbNoScoresMessage.style.display = 'none';

                let url = `/api/leaderboard?mode=${encodeURIComponent(mode)}&limit=20`;
                if (difficulty && difficulty !== "") {
                    url += `&difficulty=${encodeURIComponent(difficulty)}`;
                }

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    displayLeaderboardInModal(data.leaderboard);
                } catch (error) {
                    console.error("Error fetching leaderboard:", error);
                    leaderboardModalBody.innerHTML = '<tr><td colspan="5" style="text-align:center; color:red;">Error loading leaderboard.</td></tr>';
                    lbNoScoresMessage.style.display = 'none';
                }
            }

            function displayLeaderboardInModal(scores) {
                if (!leaderboardModalBody || !lbNoScoresMessage) return;
                leaderboardModalBody.innerHTML = '';

                if (!scores || scores.length === 0) {
                    lbNoScoresMessage.style.display = 'block';
                    return;
                }
                lbNoScoresMessage.style.display = 'none';

                scores.forEach((score, index) => {
                    const row = leaderboardModalBody.insertRow();
                    row.insertCell().textContent = index + 1;
                    row.insertCell().textContent = score.player_name;
                    row.insertCell().textContent = score.score;
                    row.insertCell().textContent = score.time_taken_seconds !== null && score.time_taken_seconds !== undefined ? score.time_taken_seconds : 'N/A';
                    let submittedDate = 'N/A';
                    if (score.timestamp) {
                        try {
                            submittedDate = new Date(score.timestamp).toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
                        } catch (e) { console.warn("Could not parse timestamp: ", score.timestamp); }
                    }
                    row.insertCell().textContent = submittedDate;
                });
            }

            function handleModalFocusTrap(event) {
                if (!currentOpenModal || !currentOpenModal.classList.contains('modal-open')) return;
                if (event.key === 'Tab') {
                    if (!modalFocusableElements || modalFocusableElements.length === 0) { event.preventDefault(); return; }
                    const firstElement = modalFocusableElements[0];
                    const lastElement = modalFocusableElements[modalFocusableElements.length - 1];
                    if (event.shiftKey) {
                        if (document.activeElement === firstElement) { lastElement.focus(); event.preventDefault(); }
                    } else {
                        if (document.activeElement === lastElement) { firstElement.focus(); event.preventDefault(); }
                    }
                } else if (event.key === 'Escape') {
                    if (currentOpenModal) {
                        closeModal(currentOpenModal);
                    }
                }
            }

            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark-theme');
                    if (themeToggleBtn) themeToggleBtn.innerHTML = `<i class="fas ${sunIconClass}"></i>`;
                    localStorage.setItem(THEME_STORAGE_KEY, 'dark');
                } else {
                    document.documentElement.classList.remove('dark-theme');
                    if (themeToggleBtn) themeToggleBtn.innerHTML = `<i class="fas ${moonIconClass}"></i>`;
                    localStorage.setItem(THEME_STORAGE_KEY, 'light');
                }
            }
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', () => {
                    if (document.documentElement.classList.contains('dark-theme')) applyTheme('light');
                    else applyTheme('dark');
                });
            }
            const savedTheme = localStorage.getItem(THEME_STORAGE_KEY);
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme) applyTheme(savedTheme); else if (prefersDark) applyTheme('dark'); else applyTheme('light');

            if(clearSelectionBtn) clearSelectionBtn.addEventListener('click', clearSelection);
            if(hintBtn) hintBtn.addEventListener('click', handleHintClick);
            if(shuffleBtn) shuffleBtn.addEventListener('click', shuffleWordGrid);

            if(confirmShowAnswerBtn) confirmShowAnswerBtn.addEventListener('click', async () => { closeModal(showAnswerModal); await revealAllGroups(); });
            if(cancelShowAnswerBtn) cancelShowAnswerBtn.addEventListener('click', () => closeModal(showAnswerModal));

            if(confirmSubmitScoreBtn) confirmSubmitScoreBtn.addEventListener('click', submitScore);
            if(cancelSubmitScoreBtn) cancelSubmitScoreBtn.addEventListener('click', () => closeModal(scoreSubmitModal));

            if (viewLeaderboardBtn) viewLeaderboardBtn.addEventListener('click', openLeaderboardModal);
            if (closeLeaderboardBtn) closeLeaderboardBtn.addEventListener('click', () => closeModal(leaderboardModal));
            if (lbFilterBtn) {
                lbFilterBtn.addEventListener('click', () => {
                    fetchLeaderboardData(lbDifficultyFilter.value || null, lbModeFilter.value);
                });
            }

            initGame();
        });
    </script>
</body>
</html>
```
