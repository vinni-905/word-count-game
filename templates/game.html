--- START OF FILE game.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordLinks - Play</title> <!-- Updated title -->

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome (for icons in modal - optional) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">


    <!-- Embedded CSS (Enhanced Version with Accessibility additions) -->
    <style>
        /* --- Base & Typography --- */
        :root {
            /* Define Color Palette */
            --bg-gradient-start: #f8f9fa; /*#e0eafc;*/
            --bg-gradient-end: #ffffff; /*#cfdef3;*/
            --container-bg: #ffffff;
            --text-primary: #343a40;
            --text-secondary: #6c757d;
            --accent-primary: #007bff; /*#4e54c8;*/
            --accent-secondary: #8f94fb;
            --selected-bg: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%); /* Purple/Blue */
            --selected-text: #ffffff;
            --solved-bg: #e9ecef;
            --solved-text: #adb5bd;
            --disabled-opacity: 0.6;
            --correct-bg: #d1e7dd; /* Light Green */
            --correct-text: #0f5132;
            --correct-border: #badbcc;
            --incorrect-bg: #f8d7da; /* Light Red */
            --incorrect-text: #842029;
            --incorrect-border: #f5c2c7;
            --hint-bg: #cff4fc; /* Light Cyan */
            --hint-text: #055160;
            --hint-border: #b6effb;
            --button-primary-bg: linear-gradient(135deg, #007bff 0%, #0056b3 100%); /* Blue */
            --button-primary-hover: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            --button-warning-bg: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); /* Yellow/Orange */
            --button-warning-hover: linear-gradient(135deg, #e0a800 0%, #c69500 100%);
            --button-info-bg: linear-gradient(135deg, #17a2b8 0%, #117a8b 100%); /* Cyan */
            --button-info-hover: linear-gradient(135deg, #117a8b 0%, #0f6674 100%);
            --button-success-bg: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); /* Green */
            --button-success-hover: linear-gradient(135deg, #1e7e34 0%, #155724 100%);
            --button-disabled-bg: #ced4da;
            --button-disabled-text: #6c757d;
            --container-border: rgba(255, 255, 255, 0.3);
            --blur-intensity: 10px;

            /* Solved Group Colors (More vibrant) */
            --solved-color-0-bg: linear-gradient(135deg, #fefae0 0%, #faedcd 100%); /* Creamy Yellow */
            --solved-color-0-text: #bc6c25;
            --solved-color-0-border: #e9c46a; /* Darker Yellow Border */
            --solved-color-1-bg: linear-gradient(135deg, #caf0f8 0%, #ade8f4 100%); /* Light Blue */
            --solved-color-1-text: #0077b6;
            --solved-color-1-border: #48cae4; /* Darker Blue Border */
            --solved-color-2-bg: linear-gradient(135deg, #d8f3dc 0%, #b7e4c7 100%); /* Mint Green */
            --solved-color-2-text: #2d6a4f;
            --solved-color-2-border: #74c69d; /* Darker Green Border */
            --solved-color-3-bg: linear-gradient(135deg, #fec8d8 0%, #ffacb7 100%); /* Pink */
            --solved-color-3-text: #c9184a;
            --solved-color-3-border: #ff758f; /* Darker Pink Border */


            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.1);

             /* Transitions */
             --transition-speed: 0.25s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            background: linear-gradient(to bottom, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-primary);
            padding: 20px;
            min-height: 100vh;
            display: flex; /* For centering container */
            align-items: center; /* For centering container */
            justify-content: center; /* For centering container */
        }

        .container {
            width: 100%; /* Use full width on small screens */
            max-width: 700px; /* Slightly wider for better spacing */
            margin: 20px auto; /* Add vertical margin */
            background: var(--container-bg);
            padding: 30px; /* More padding */
            border-radius: 16px; /* More rounded */
            box-shadow: var(--shadow-lg);
        }

         h1 { text-align: center; color: var(--text-primary); margin-bottom: 15px; font-weight: 700; }
         h2 { text-align: center; color: var(--text-secondary); margin-bottom: 25px; font-weight: 600; }

        /* --- Status Bar --- */
        .status-bar {
            display: flex;
            justify-content: space-around; /* Even distribution */
            align-items: center;
            padding: 15px 0;
            margin-bottom: 25px;
            border-bottom: 1px solid #dee2e6;
            flex-wrap: wrap;
            gap: 15px;
            background-color: #f8f9fa; /* Slight bg */
            border-radius: 8px; /* Rounded corners for the bar */
            box-shadow: var(--shadow-sm);
        }
        .status-bar div {
            font-weight: 600;
            font-size: 0.9em;
            text-align: center;
            flex-basis: auto;
            flex-grow: 1;
             color: var(--text-secondary); /* Subtler text */
        }
         .status-bar span {
             font-weight: 700;
             color: var(--accent-primary); /* Highlight values */
             font-size: 1.1em; /* Make values slightly larger */
             margin-left: 5px; /* Space out label and value */
         }
         #timer {
             min-width: 80px; /* Ensure space for MM:SS */
         }

        /* --- Word Grid & Items --- */
        #word-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px; /* Slightly larger gap */
            margin-bottom: 30px; /* More space below grid */
        }

        .word-item {
            background-color: #f8f9fa; /* Lighter base */
            padding: 15px 8px; /* Adjust padding */
            text-align: center;
            border-radius: 8px; /* Consistent rounding */
            cursor: pointer;
            font-weight: 600; /* Slightly bolder */
            text-transform: uppercase;
            transition: background-color var(--transition-speed) ease,
                        color var(--transition-speed) ease,
                        transform var(--transition-speed) ease,
                        box-shadow var(--transition-speed) ease;
            user-select: none;
            min-height: 3.5em; /* Ensure height */
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            word-break: break-word;
            box-shadow: var(--shadow-sm);
            border: 1px solid #dee2e6; /* Subtle border */
        }

        .word-item:hover:not(.selected):not(.solved):not(.disabled) {
             background-color: #e9ecef; /* Hover effect */
             transform: translateY(-3px); /* Lift effect */
             box-shadow: var(--shadow-md);
        }

        /* --- ACCESSIBILITY: Style for keyboard focus --- */
        .word-item:focus-visible {
            outline: 3px solid var(--accent-primary);
            outline-offset: 2px;
            box-shadow: var(--shadow-md); /* Enhance focus visibility */
        }

        .word-item.selected {
            background: var(--selected-bg);
            color: var(--selected-text);
            transform: scale(1.05) translateY(-2px); /* Pop effect */
            box-shadow: var(--shadow-md);
            border: none; /* Remove border when selected */
        }

        .word-item.solved,
        .word-item.disabled { /* Combine solved and disabled styles */
            background-color: var(--solved-bg);
            color: var(--solved-text);
            cursor: default;
            opacity: var(--disabled-opacity);
            box-shadow: none;
            border: 1px solid #ced4da;
            transform: none; /* Reset transforms */
        }
        /* Override specific background for solved items if needed, but unified disabled look is often good */
        .word-item.solved {
             /* Keep background var(--solved-bg) or customize if needed */
        }


        /* --- Controls & Buttons --- */
        .controls {
            text-align: center;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between; /* Better alignment */
            align-items: center;
            flex-wrap: wrap;
            gap: 15px; /* Consistent gap */
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: var(--shadow-sm);
        }
        .controls p {
            margin: 0; /* Remove default margin */
            white-space: nowrap;
            font-size: 0.9em;
            color: var(--text-secondary);
             flex-grow: 1; /* Allow text paragraphs to take space */
             text-align: center;
        }
         .controls p span { /* Style the numbers */
             font-weight: 700;
             color: var(--accent-primary);
             font-size: 1.1em;
         }

        .controls button {
            padding: 10px 20px; /* More padding */
            cursor: pointer;
            border-radius: 25px; /* Pill shape */
            border: none;
            font-weight: 600;
            font-size: 0.9em;
            color: white;
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm);
            flex-shrink: 0; /* Prevent buttons shrinking too much */
        }
        .controls button:hover:not(:disabled) {
             transform: translateY(-2px);
             box-shadow: var(--shadow-md);
        }
         .controls button:active:not(:disabled) {
             transform: translateY(0);
             box-shadow: var(--shadow-sm);
         }

        #clear-selection-btn { background: var(--button-warning-bg); }
        #clear-selection-btn:hover:not(:disabled) { background: var(--button-warning-hover); }

        #hint-btn { background: var(--button-info-bg); }
        #hint-btn:hover:not(:disabled) { background: var(--button-info-hover); }

        .controls button:disabled {
            background: var(--button-disabled-bg);
            color: var(--button-disabled-text);
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }


        /* --- Feedback Area --- */
        #feedback-area {
            margin-top: 15px; /* Reset margin */
            margin-bottom: 25px; /* Add space below */
            padding: 15px 20px;
            border-radius: 8px;
            min-height: 3em;
            text-align: center;
            font-weight: 600;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            border: 1px solid transparent; /* Placeholder for borders */
        }
        .feedback-correct { background-color: var(--correct-bg); color: var(--correct-text); border-color: var(--correct-border); }
        .feedback-incorrect { background-color: var(--incorrect-bg); color: var(--incorrect-text); border-color: var(--incorrect-border); }
        .feedback-hint { background-color: var(--hint-bg); color: var(--hint-text); border-color: var(--hint-border); }

        /* --- Solved Groups Area --- */
        #solved-groups-area {
            margin-bottom: 30px; /* More space */
            display: grid;
            grid-template-columns: 1fr; /* Stack vertically */
            gap: 15px; /* Consistent gap */
        }
        .solved-group {
            border-radius: 12px; /* Smoother corners */
            padding: 15px 20px;
            text-align: center;
            box-shadow: var(--shadow-md);
            border-width: 2px; /* Make border slightly thicker */
            border-style: solid;
            transition: transform 0.3s ease-out, opacity 0.5s ease-out; /* Updated transition */
            transform: scale(0.95); /* Start slightly smaller */
            opacity: 0; /* Start hidden */
            animation: fadeInScale 0.5s ease-out forwards; /* Animation */
        }
        @keyframes fadeInScale {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        /* Add cursor pointer only after game ends */
        .solved-group.reviewable {
            cursor: pointer;
        }
         .solved-group.reviewable:hover {
             box-shadow: var(--shadow-lg); /* Add hover effect for review */
             transform: scale(1.02);
         }


        .solved-group strong {
            display: block;
            margin-bottom: 8px; /* More space */
            text-transform: uppercase;
            font-size: 1em; /* Slightly larger */
            font-weight: 700;
        }
        .solved-group p {
            margin: 0;
            font-size: 0.95em;
            font-weight: 400; /* Regular weight for words */
            line-height: 1.5;
        }

        /* Apply distinct solved group colors */
        .solved-group-color-0 { background: var(--solved-color-0-bg); color: var(--solved-color-0-text); border-color: var(--solved-color-0-border); animation-delay: 0s; }
        .solved-group-color-1 { background: var(--solved-color-1-bg); color: var(--solved-color-1-text); border-color: var(--solved-color-1-border); animation-delay: 0.1s; }
        .solved-group-color-2 { background: var(--solved-color-2-bg); color: var(--solved-color-2-text); border-color: var(--solved-color-2-border); animation-delay: 0.2s; }
        .solved-group-color-3 { background: var(--solved-color-3-bg); color: var(--solved-color-3-text); border-color: var(--solved-color-3-border); animation-delay: 0.3s; }


        /* --- POST-GAME REVIEW HIGHLIGHT --- */
        .word-item.highlight-review {
            background-color: var(--hint-bg) !important; /* Use hint color, !important needed to override other states */
            color: var(--hint-text) !important;
            border-color: var(--hint-border) !important;
            opacity: 1 !important; /* Ensure visible */
            transition: background-color 0.1s ease-out, color 0.1s ease-out, border-color 0.1s ease-out;
        }

        /* --- VISUAL HINT HIGHLIGHT --- */
        .word-item.highlight-hint {
            outline: 3px dashed var(--accent-secondary); /* Dashed outline */
            outline-offset: 2px;
            transition: outline 0.2s ease-out;
            /* Make sure hint outline is visible even on selected items */
            position: relative; /* Needed for z-index */
            z-index: 5;
        }


        /* --- New Game Button & Utility --- */
        #new-game-btn {
            display: block; /* Use block for centering with margin auto */
            width: fit-content; /* Fit content */
            margin: 30px auto 0; /* Centered, with top margin */
            padding: 12px 30px; /* Generous padding */
            font-size: 1.1em; /* Larger text */
            cursor: pointer;
            background: var(--button-success-bg);
            color: white;
            border: none;
            border-radius: 30px; /* Pill shape */
            font-weight: 600;
            box-shadow: var(--shadow-md);
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
             /* Add display: flex to easily center icon + text if needed */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        #new-game-btn:hover {
            background: var(--button-success-hover);
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
        }

        /* --- Error & Loading --- */
        .error-message, /* Renamed class */
        #loading-message,
        #puzzle-info { /* Consistent styling for info texts */
             text-align: center;
             color: var(--text-secondary);
             font-style: italic;
             margin-bottom: 20px;
        }
        .error-message { /* Specific error styling */
             color: var(--incorrect-text);
             background-color: var(--incorrect-bg);
             border: 1px solid var(--incorrect-border);
             padding: 10px 15px;
             border-radius: 8px;
             font-weight: 600;
             margin-top: 15px;
             font-style: normal; /* Override italic */
        }


        /* --- Shake Animation --- */
        @keyframes shake {
            0%, 100% { transform: translateX(0) scale(1.05) translateY(-2px); } /* Keep selected style */
            25% { transform: translateX(-6px) scale(1.05) translateY(-2px); }
            50% { transform: translateX(6px) scale(1.05) translateY(-2px); }
            75% { transform: translateX(-6px) scale(1.05) translateY(-2px); }
        }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed;
            inset: 0; /* top, right, bottom, left = 0 */
            background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure it's on top */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
        }

        .modal-overlay.modal-open {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease;
        }

        .modal-content {
            background: var(--container-bg);
            padding: 30px 40px;
            border-radius: 15px;
            border: 1px solid var(--container-border);
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(var(--blur-intensity));
            -webkit-backdrop-filter: blur(var(--blur-intensity));
            max-width: 450px; /* Limit width */
            width: 90%;
            text-align: center;
            color: var(--text-primary);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal-overlay.modal-open .modal-content {
            transform: scale(1);
        }

        .modal-title {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--accent-primary); /* Highlight title */
        }

        .modal-content p {
            margin-bottom: 25px;
            font-size: 1em;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .modal-actions {
            display: flex;
            justify-content: space-around; /* Or center/space-between */
            gap: 15px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .modal-button {
            padding: 10px 25px;
            cursor: pointer;
            border-radius: 25px;
            border: 1px solid transparent; /* Simplified border */
            font-weight: 600;
            font-size: 0.9em;
            color: #fff; /* White text on gradient buttons */
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .modal-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: var(--shadow-md);
        }

        .modal-button-confirm {
            background: var(--button-success-bg);
        }
        .modal-button-confirm:hover:not(:disabled) {
            background: var(--button-success-hover);
        }

        .modal-button-cancel {
            background: var(--button-warning-bg);
            color: var(--text-primary); /* Better contrast on yellow */
        }
        .modal-button-cancel:hover:not(:disabled) {
            background: var(--button-warning-hover);
        }

        /* Add icons if needed, like previous buttons */
        .modal-button i {
            font-size: 1.1em;
        }

        @media (max-width: 480px) {
            .modal-content { padding: 20px 25px; }
            .modal-title { font-size: 1.3em; }
            .modal-actions { flex-direction: column; align-items: center; }
            .modal-button { width: 80%; justify-content: center; }
        }


        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            .container { padding: 20px; }
            h1 { font-size: 1.8em; }
             .status-bar { padding: 10px; }
            .status-bar div { font-size: 0.85em; }
            .status-bar span { font-size: 1em; }
             #word-grid { gap: 10px; }
             .word-item { font-size: 0.9em; min-height: 3.2em; padding: 12px 5px; }
             .controls { flex-direction: column; gap: 10px; padding: 10px; }
             .controls p { order: -1; /* Put text at top */ margin-bottom: 10px; text-align: center; }
             .controls button { width: 60%; /* Make buttons wider */ padding: 10px 15px; font-size: 0.9em;}
            #new-game-btn { padding: 10px 25px; font-size: 1em; }
        }

        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; border-radius: 12px; }
            h1 { font-size: 1.5em; margin-bottom: 10px;}
            h2 { font-size: 1em; margin-bottom: 15px; }
            .status-bar { flex-direction: column; align-items: stretch; gap: 8px; padding: 8px; }
            .status-bar div { text-align: left; padding: 0 10px; } /* Align left in column */
             #word-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 20px;} /* 2 columns */
             .word-item { font-size: 0.85em; min-height: 3.5em; font-weight: 600; } /* Ensure readability */
             .controls { gap: 10px; }
            .controls button { width: 80%; }
             #feedback-area { padding: 10px 15px; font-size: 0.9em;}
            .solved-group { padding: 10px 15px; }
            .solved-group strong { font-size: 0.9em; }
            .solved-group p { font-size: 0.9em; }
            #new-game-btn { width: 70%; }
        }

    </style>
</head>
<body>
    <!-- Container and all child elements -->
    <div class="container game-container">
        <h1>WordLinks</h1>
        <!-- Status Bar -->
        <div class="status-bar">
            <div>Time: <span id="timer">00:00</span></div>
            <div>Score: <span id="score">1000</span></div>
            <div>Hints: <span id="hints-used">0</span> / <span id="hints-allowed">3</span></div>
            <div>Mistakes: <span id="lives-remaining">4</span></div>
        </div>

        <p id="loading-message">Loading puzzle...</p>
        <p id="error-message" class="error-message" style="display: none;"></p> <!-- Initially hidden -->
        <div id="puzzle-info" style="text-align: center; font-style: italic; margin-bottom: 15px;"></div>

        <!-- Solved groups appear above grid -->
        <div id="solved-groups-area"></div>

        <!-- The dynamic grid with accessibility role -->
        <div id="word-grid" role="grid"></div>

        <!-- Controls Area -->
        <div class="controls">
             <p>Selected: <span id="selected-count">0</span> / 4</p>
             <button id="clear-selection-btn" disabled>Clear</button>
             <button id="hint-btn">Hint</button>
        </div>

        <!-- Feedback Area with ARIA live region -->
         <div id="feedback-area" aria-live="polite" aria-atomic="true"></div>

        <!-- Show Answer Confirmation Modal -->
        <div id="show-answer-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <h3 class="modal-title"><i class="fas fa-eye"></i> Hints Exhausted</h3>
                <p>You've used all available hints. Would you like to reveal the solution?</p>
                <div class="modal-actions">
                    <button id="confirm-show-answer-btn" class="modal-button modal-button-confirm">
                        <i class="fas fa-check"></i> Show Answer
                    </button>
                    <button id="cancel-show-answer-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Keep Playing
                    </button>
                </div>
            </div>
        </div>

         <!-- Play Again Button -->
         <button id="new-game-btn" style="display: none;">
              <i class="fas fa-redo"></i> Play Again? <!-- Optional Icon -->
         </button>
    </div>

    <!-- Embedded JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const wordGrid = document.getElementById('word-grid');
            const loadingMessage = document.getElementById('loading-message');
            const errorMessage = document.getElementById('error-message'); // Corrected ID usage
            const selectedCountSpan = document.getElementById('selected-count');
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            const feedbackArea = document.getElementById('feedback-area');
            const solvedGroupsArea = document.getElementById('solved-groups-area');
            const newGameBtn = document.getElementById('new-game-btn');
            const livesRemainingSpan = document.getElementById('lives-remaining');
            const puzzleInfoDiv = document.getElementById('puzzle-info');
            const timerSpan = document.getElementById('timer');
            const scoreSpan = document.getElementById('score');
            const hintBtn = document.getElementById('hint-btn');
            const hintsUsedSpan = document.getElementById('hints-used');
            const hintsAllowedSpan = document.getElementById('hints-allowed');
            const showAnswerModal = document.getElementById('show-answer-modal');
            const confirmShowAnswerBtn = document.getElementById('confirm-show-answer-btn');
            const cancelShowAnswerBtn = document.getElementById('cancel-show-answer-btn');

            // --- Game Configuration ---
            const STARTING_LIVES = 4;
            const STARTING_SCORE = 1000;
            const INCORRECT_GUESS_PENALTY = 75;
            const HINT_PENALTY = 150;
            const MAX_HINTS = 3;
            const TIME_PENALTY_PER_SECOND = 1; // Example, currently not used in timer logic
            const PUZZLE_STORAGE_KEY = 'currentPuzzle'; // From sessionStorage
            const STATS_STORAGE_KEY = 'wordLinksGameStats'; // From localStorage

            // --- Game State Variables ---
            let currentPuzzle = null;
            let selectedWords = [];
            let lives = STARTING_LIVES;
            let score = STARTING_SCORE;
            let hintsUsed = 0;
            let revealedGroupsCount = 0;
            let solvedGroupKeys = []; // Stores keys/IDs of solved groups from backend if provided
            let isSubmitting = false;
            let gameActive = false;
            let timerInterval = null;
            let startTime = null;
            let feedbackTimeout = null;
            let gameStats = { wins: 0, losses: 0, currentStreak: 0, maxStreak: 0, fastestTime: null }; // Stats object


            // --- Initialization Function ---
            function initGame() {
                closeShowAnswerModal();
                stopTimer();
                gameActive = false;

                // ADD: Load stats at the beginning
                loadStats();

                const puzzleDataString = sessionStorage.getItem(PUZZLE_STORAGE_KEY);
                if (!puzzleDataString) {
                    showError('No puzzle data found. Please start a new game from the home page.');
                    loadingMessage.style.display = 'none';
                    disableAllInteraction();
                    newGameBtn.style.display = 'flex'; // Show play again to allow going back
                    newGameBtn.onclick = goToHome;
                    return;
                }

                try {
                    currentPuzzle = JSON.parse(puzzleDataString);
                    if (!currentPuzzle || !currentPuzzle.words || !currentPuzzle.puzzle_id) {
                         throw new Error("Invalid puzzle data format.");
                    }

                    lives = STARTING_LIVES;
                    score = STARTING_SCORE;
                    hintsUsed = 0;
                    selectedWords = [];
                    solvedGroupKeys = [];
                    revealedGroupsCount = 0;
                    isSubmitting = false;

                    clearFeedback();
                    solvedGroupsArea.innerHTML = '';
                    errorMessage.style.display = 'none'; // Hide error message initially
                    errorMessage.textContent = '';
                    loadingMessage.style.display = 'none';
                    wordGrid.innerHTML = ''; // Clear previous grid
                    puzzleInfoDiv.innerHTML = ''; // Clear previous info

                    // Display puzzle info (ID, Difficulty)
                    if (currentPuzzle.difficulty || currentPuzzle.puzzle_id) {
                         const infoP = document.createElement('p');
                         let infoText = [];
                         if(currentPuzzle.puzzle_id) infoText.push(`Puzzle #${currentPuzzle.puzzle_id}`);
                         if(currentPuzzle.difficulty) infoText.push(`Difficulty: ${currentPuzzle.difficulty}`);
                         infoP.textContent = infoText.join(' | ');
                         puzzleInfoDiv.appendChild(infoP);
                    }

                    displayWords(currentPuzzle.words);
                    updateScoreDisplay();
                    updateLivesDisplay();
                    updateHintsDisplay();
                    updateSelectionUI();

                    newGameBtn.style.display = 'none'; // Hide until game ends
                    enableAllInteraction(); // Sets up listeners and ARIA/tabindex

                    startTime = Date.now();
                    startTimer();
                    gameActive = true;

                    // ADD: Set initial focus for keyboard users
                    setInitialFocus();

                } catch (error) {
                    console.error("Error initializing game:", error);
                    showError(`Failed to load puzzle: ${error.message}. Please try starting a new game.`);
                    loadingMessage.style.display = 'none';
                    disableAllInteraction();
                     newGameBtn.style.display = 'flex'; // Show play again on error
                     newGameBtn.onclick = goToHome;
                }
            }

            // --- UI Update Functions ---

            function displayWords(words) {
                wordGrid.innerHTML = ''; // Clear previous items
                const shuffledWords = [...words].sort(() => Math.random() - 0.5);

                shuffledWords.forEach((word) => {
                    const wordDiv = document.createElement('div');
                    wordDiv.classList.add('word-item');
                    wordDiv.textContent = word;
                    wordDiv.dataset.word = word; // Store word for logic

                    // --- ACCESSIBILITY ADDITIONS ---
                    wordDiv.setAttribute('role', 'gridcell');
                    wordDiv.setAttribute('aria-selected', 'false');
                    // tabindex will be set by enable/disable interaction functions
                    // --- END ACCESSIBILITY ---

                    wordDiv.addEventListener('click', handleWordClick);
                    wordDiv.addEventListener('keydown', handleWordKeyDown); // ADD: Key listener

                    wordGrid.appendChild(wordDiv);
                });

                setupGridNavigation(); // ADD: Setup arrow key nav
            }

            function updateSelectionUI() {
                selectedCountSpan.textContent = selectedWords.length;
                clearSelectionBtn.disabled = selectedWords.length === 0 || isSubmitting || !gameActive;
                hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
            }

            function updateLivesDisplay() {
                 livesRemainingSpan.textContent = lives;
                 const livesDiv = livesRemainingSpan.closest('div');
                 if(livesDiv) {
                    livesDiv.style.color = lives <= 1 ? '#dc3545' : 'var(--text-secondary)';
                    livesRemainingSpan.style.color = lives <= 1 ? '#dc3545' : 'var(--accent-primary)';
                 }
            }

            function updateScoreDisplay() {
                 scoreSpan.textContent = Math.max(0, score); // Ensure score doesn't go below 0 visually
            }

            function updateHintsDisplay() {
                 hintsUsedSpan.textContent = hintsUsed;
                 hintsAllowedSpan.textContent = MAX_HINTS;
                 hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
            }

            // --- Timer Functions ---
            function startTimer() {
                stopTimer(); // Clear any existing interval
                timerInterval = setInterval(() => {
                    if (!gameActive || !startTime) return;

                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - startTime) / 1000);

                    // Optional continuous time penalty - keep commented unless desired
                    // if (elapsedSeconds > 0 && elapsedSeconds % 1 === 0) {
                    //     score -= TIME_PENALTY_PER_SECOND;
                    //     updateScoreDisplay();
                    // }

                    const minutes = Math.floor(elapsedSeconds / 60);
                    const seconds = elapsedSeconds % 60;
                    timerSpan.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                }, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // --- Event Handlers ---
            function handleWordClick(event) {
                 const wordDiv = event.currentTarget;
                 // Check states before processing
                 if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                 toggleWordSelection(wordDiv); // Use refactored logic
            }

            // ADD: New handler for keyboard events on words
            function handleWordKeyDown(event) {
                // Handle selection keys
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault(); // Prevent default space scroll/enter submit
                    const wordDiv = event.currentTarget;
                    if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                    toggleWordSelection(wordDiv); // Use the same selection logic
                }
                // Arrow keys are handled by the grid listener (setupGridNavigation)
            }

            // ADD: Refactored word selection logic
            function toggleWordSelection(wordDiv) {
                 const word = wordDiv.dataset.word;
                 const isSelected = wordDiv.classList.contains('selected');

                 clearFeedback(); // Clear feedback on interaction

                 if (isSelected) {
                      selectedWords = selectedWords.filter(w => w !== word);
                      wordDiv.classList.remove('selected');
                      wordDiv.setAttribute('aria-selected', 'false'); // ARIA Update
                 } else {
                      if (selectedWords.length < 4) {
                           selectedWords.push(word);
                           wordDiv.classList.add('selected');
                           wordDiv.setAttribute('aria-selected', 'true'); // ARIA Update
                      } else {
                           // Optional: Indicate max selected visually or audibly if desired
                           // Maybe shake the 4 selected items briefly?
                      }
                 }
                 updateSelectionUI();
                 // Auto-submit if 4 words are selected
                 if (selectedWords.length === 4) {
                     setTimeout(submitGroupAttempt, 150); // Slightly longer delay for visual feedback
                 }
            }

            function openShowAnswerModal() {
                if (showAnswerModal) {
                    showAnswerModal.style.display = 'flex';
                    setTimeout(() => { showAnswerModal.classList.add('modal-open'); }, 10);
                }
            }

            function closeShowAnswerModal() {
                if (showAnswerModal) {
                    showAnswerModal.classList.remove('modal-open');
                    setTimeout(() => {
                        if (!showAnswerModal.classList.contains('modal-open')) {
                             showAnswerModal.style.display = 'none';
                        }
                    }, 300); // Match CSS transition duration
                }
            }

            function clearSelection() {
                 clearFeedback(); // Clear feedback on interaction
                 selectedWords = [];
                 document.querySelectorAll('.word-item.selected').forEach(el => {
                    el.classList.remove('selected');
                    el.setAttribute('aria-selected', 'false'); // ARIA Update
                 });
                 updateSelectionUI();
            }

            async function handleHintClick() {
                if (!gameActive || isSubmitting || hintsUsed >= MAX_HINTS || lives <= 0) return;

                isSubmitting = true; // Disable buttons
                updateSelectionUI();

                // Penalize FIRST, then call API
                score -= HINT_PENALTY;
                hintsUsed++;
                updateScoreDisplay();
                updateHintsDisplay(); // This might disable the button now

                 clearFeedback(); // Clear previous feedback

                try {
                    await new Promise(resolve => setTimeout(resolve, 300)); // Simulate network
                    const response = await fetch('/api/get_hint', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                             puzzle_id: currentPuzzle.puzzle_id,
                             solved_group_keys: solvedGroupKeys // Send solved group keys/ids if backend uses them
                        }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: `HTTP error ${response.status}` }));
                        throw new Error(errorData.detail || `Hint Error: ${response.status}`);
                    }
                    const result = await response.json();

                    // --- MODIFICATION FOR VISUAL HINT ---
                    // ASSUMPTION: API provides result.words array
                    if (result.hint && result.words && Array.isArray(result.words)) {
                        showFeedback(result.hint, 'feedback-hint', 5000); // Show text
                        highlightHintWords(result.words); // Highlight words visually

                        if (hintsUsed >= MAX_HINTS) {
                             // Release submitting state *before* opening modal
                             isSubmitting = false;
                             updateSelectionUI();
                             // Open modal slightly after showing hint/highlight
                             setTimeout(openShowAnswerModal, 1000);
                        } else {
                             isSubmitting = false; // Release submitting state
                             updateSelectionUI(); // Update button states
                        }
                    } else if (result.hint) { // Fallback: Only hint text provided
                         showFeedback(result.hint, 'feedback-hint', hintsUsed >= MAX_HINTS ? 5000 : 4000);
                         if (hintsUsed >= MAX_HINTS) {
                              isSubmitting = false;
                              updateSelectionUI();
                              setTimeout(openShowAnswerModal, 1000);
                         } else {
                             isSubmitting = false;
                             updateSelectionUI();
                         }
                    } else {
                        // No hint available message from backend
                        showFeedback(result.message || "No hint available.", '', 3000);
                        // Revert penalty/count if backend indicated no hint was given
                        hintsUsed--;
                        score += HINT_PENALTY;
                        updateScoreDisplay();
                        updateHintsDisplay();
                        isSubmitting = false;
                        updateSelectionUI();
                    }
                    // --- END VISUAL HINT ---

                } catch (error) {
                    console.error('Error getting hint:', error);
                    showFeedback(`Hint Failed: ${error.message}`, 'feedback-incorrect', 4000);
                    // Revert penalty/count ONLY IF WE INCREMENTED IT FIRST
                    if(hintsUsed > 0) { // Check if we actually used a hint count
                        hintsUsed--;
                        score += HINT_PENALTY;
                    }
                    updateScoreDisplay();
                    updateHintsDisplay();
                    isSubmitting = false;
                    updateSelectionUI();
                }
            }


            function clearFeedback() {
                if (feedbackTimeout) {
                    clearTimeout(feedbackTimeout);
                    feedbackTimeout = null;
                }
                if (feedbackArea) {
                    feedbackArea.textContent = '';
                    feedbackArea.className = 'feedback-area';
                }
            }

             function showFeedback(message, className = '', duration = 3000) {
                 if (!feedbackArea) { return; }
                 clearFeedback(); // Clear previous feedback first

                 feedbackArea.textContent = message;
                 feedbackArea.className = 'feedback-area'; // Reset base class
                 if (className) {
                     feedbackArea.classList.add(className);
                 }

                 // Only set a timeout if duration is positive
                 if (duration > 0) {
                     feedbackTimeout = setTimeout(() => {
                         if (feedbackArea && feedbackArea.textContent === message) { // Check if message is still the same
                             clearFeedback();
                         }
                     }, duration);
                 }
             }

             function showError(message) {
                  errorMessage.textContent = message;
                  errorMessage.style.display = 'block';
             }

            // --- Game Logic Functions ---
            async function submitGroupAttempt() {
                if (!gameActive || isSubmitting || selectedWords.length !== 4 || lives <= 0) return;

                isSubmitting = true;
                updateSelectionUI();
                clearFeedback(); // Clear previous message
                showFeedback('Checking...', '', 0); // Show indefinite "Checking..." message

                const attemptPayload = {
                     puzzle_id: currentPuzzle.puzzle_id,
                     groups: { 'attempt': selectedWords } // Assuming backend expects this structure
                };

                await new Promise(resolve => setTimeout(resolve, 300)); // Simulate network delay

                try {
                    const response = await fetch('/api/check_answer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(attemptPayload)
                    });

                    if (!response.ok) {
                        let errorText = `Check Error: ${response.status}`;
                         try { const errorData = await response.json(); errorText = errorData.detail || errorText; } catch (e) { /* Ignore */ }
                        throw new Error(errorText);
                    }

                    const result = await response.json();
                    handleAttemptResult(result); // Process the backend response

                } catch (error) {
                     console.error('Error submitting answer:', error);
                     showFeedback(`Failed to check answer: ${error.message}. Try again.`, 'feedback-incorrect', 4000);
                     clearSelection(); // Clear selection on error
                } finally {
                     isSubmitting = false;
                     // updateSelectionUI() is called within handleAttemptResult or clearSelection
                }
            }

             function handleAttemptResult(result) {
                 // Determine if the guess was correct based on the backend response structure.
                 // This might involve checking if a new group key exists in `result.solved_groups`
                 // compared to the local `solvedGroupKeys` array.
                 let foundCorrectGroup = false;
                 let correctGroupDescription = "";
                 let newlySolvedKey = null;
                 let difficultyIndex = 0; // Default index if backend doesn't provide one

                 const currentResultSolvedKeys = Object.keys(result.solved_groups || {});
                 const justSolvedKeys = currentResultSolvedKeys.filter(key => !solvedGroupKeys.includes(key));

                 if (justSolvedKeys.length > 0) {
                     foundCorrectGroup = true;
                     newlySolvedKey = justSolvedKeys[0]; // Assume only one new group per correct guess
                     const solvedGroupData = result.solved_groups[newlySolvedKey];

                      if (typeof solvedGroupData === 'object' && solvedGroupData !== null) {
                         // If backend returns object like { description: "...", difficulty_index: 1 }
                         correctGroupDescription = solvedGroupData.description || "Group Found";
                         difficultyIndex = solvedGroupData.difficulty_index !== undefined ? solvedGroupData.difficulty_index : revealedGroupsCount;
                      } else if (typeof solvedGroupData === 'string') {
                         // If backend returns just the description string
                         correctGroupDescription = solvedGroupData;
                         difficultyIndex = revealedGroupsCount; // Fallback index
                      }

                     if (!solvedGroupKeys.includes(newlySolvedKey)) {
                         solvedGroupKeys.push(newlySolvedKey); // Track solved group keys/IDs if needed
                     }
                 }


                  if (foundCorrectGroup) {
                       // --- Correct Guess ---
                       showFeedback(result.message || "Correct!", 'feedback-correct', 1500); // Show feedback briefly
                       const wordsInSolvedGroup = selectedWords.slice(); // Copy before clearing

                       // Display the solved group visually
                       displaySolvedGroup(correctGroupDescription, wordsInSolvedGroup, difficultyIndex);
                       revealedGroupsCount++;

                       selectedWords = []; // Clear selection immediately
                       updateSelectionUI();

                       if (revealedGroupsCount === 4) {
                           // All groups solved - WIN
                            setTimeout(() => {
                                showFeedback("Congratulations! Puzzle Solved!", 'feedback-correct', 0); // Indefinite win message
                                endGame(true); // Win
                            }, 600); // Delay after last group animation
                       }
                       // No else needed, just wait for next selection

                  } else {
                       // --- Incorrect Guess ---
                       showFeedback(result.message || "Incorrect. Try again.", 'feedback-incorrect', 1800); // Show longer
                       lives--;
                       score -= INCORRECT_GUESS_PENALTY;
                       updateScoreDisplay();
                       updateLivesDisplay();
                       shakeWords(); // Shake the currently selected (incorrect) words

                       if (lives <= 0) {
                           // Out of lives - LOSE
                            setTimeout(() => {
                                showFeedback("Game Over! You're out of mistakes.", 'feedback-incorrect', 0); // Indefinite loss message
                                endGame(false); // Lose
                            }, 600); // Delay after shake
                       } else {
                            // Clear selection after shake animation + pause
                            setTimeout(clearSelection, 800);
                       }
                  }
             }

            function displaySolvedGroup(description, wordsInGroup, colorIndex) {
                 const groupDiv = document.createElement('div');
                 groupDiv.classList.add('solved-group');
                 // Clamp color index between 0 and 3
                 const actualColorIndex = Math.min(Math.max(colorIndex, 0), 3);
                 groupDiv.classList.add(`solved-group-color-${actualColorIndex}`);

                 // ADD: Store words for post-game review
                 groupDiv.dataset.words = JSON.stringify(wordsInGroup);

                 const descStrong = document.createElement('strong'); descStrong.textContent = description; groupDiv.appendChild(descStrong);
                 const wordsP = document.createElement('p'); wordsP.textContent = wordsInGroup.sort().join(', '); groupDiv.appendChild(wordsP);

                 // Prepend solved groups
                 if (solvedGroupsArea.firstChild) {
                     solvedGroupsArea.insertBefore(groupDiv, solvedGroupsArea.firstChild);
                 } else {
                     solvedGroupsArea.appendChild(groupDiv);
                 }

                 // Update word items in the grid
                 wordsInGroup.forEach(word => {
                       const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]`);
                       if (wordDiv) {
                            wordDiv.classList.add('solved');
                            wordDiv.classList.remove('selected', 'highlight-hint'); // Ensure selection and hint highlights are removed
                            wordDiv.removeEventListener('click', handleWordClick);
                            wordDiv.removeEventListener('keydown', handleWordKeyDown); // Remove key listener
                            wordDiv.style.cursor = 'default';
                            // ARIA updates for solved state
                            wordDiv.setAttribute('aria-selected', 'false');
                            wordDiv.setAttribute('aria-disabled', 'true');
                            wordDiv.removeAttribute('tabindex'); // Make non-focusable
                       }
                  });

                 reorderGrid(); // Move solved items down visually
            }

            function reorderGrid() {
                const solvedItems = Array.from(wordGrid.querySelectorAll('.word-item.solved'));
                const activeItems = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved)'));

                wordGrid.innerHTML = ''; // Clear grid content
                activeItems.forEach(item => wordGrid.appendChild(item)); // Add active first
                solvedItems.forEach(item => wordGrid.appendChild(item)); // Add solved last
            }

            function shakeWords() {
                 document.querySelectorAll('.word-item.selected').forEach(div => {
                      div.style.animation = 'none'; // Reset animation first
                      void div.offsetWidth; // Trigger reflow to restart animation
                      div.style.animation = 'shake 0.5s ease-in-out';
                 });
            }

            // --- Game End / State Management ---
            function endGame(isWin) {
                 if (!gameActive) return; // Prevent multiple calls
                 gameActive = false;
                 stopTimer();
                 disableAllInteraction(); // Make grid non-interactive
                 closeShowAnswerModal(); // Ensure modal is closed

                 score = Math.max(0, score); // Final score check
                 updateScoreDisplay();

                 // --- STATS TRACKING UPDATE ---
                 const endTime = Date.now();
                 const solveTimeSeconds = startTime ? Math.floor((endTime - startTime) / 1000) : null;

                 if (isWin) {
                     gameStats.wins++;
                     gameStats.currentStreak++;
                     gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                     if (solveTimeSeconds !== null) {
                         if (gameStats.fastestTime === null || solveTimeSeconds < gameStats.fastestTime) {
                             gameStats.fastestTime = solveTimeSeconds;
                         }
                     }
                 } else {
                     gameStats.losses++;
                     gameStats.currentStreak = 0;
                 }
                 saveStats(); // Save updated stats
                 // --- END STATS TRACKING ---

                 newGameBtn.style.display = 'flex'; // Show Play Again button
                 newGameBtn.onclick = goToHome; // Set action

                 // --- ADD POST-GAME REVIEW ---
                 addPostGameReviewListeners();
            }

            async function revealAllGroups() {
                if (!currentPuzzle?.puzzle_id) return;

                // Ensure game state reflects end if called directly
                if (gameActive) {
                    gameActive = false;
                    stopTimer();
                }
                clearFeedback();
                showFeedback('Revealing solution...', '', 0);

                try {
                     await new Promise(resolve => setTimeout(resolve, 400)); // Simulate fetch
                     // --- Adjust API endpoint ---
                     const response = await fetch(`/api/get_solution/${currentPuzzle.puzzle_id}`);
                     if (!response.ok) throw new Error('Could not fetch solution');
                     const solution = await response.json();

                     // Reset visual state before showing solution
                     solvedGroupsArea.innerHTML = '';
                     wordGrid.querySelectorAll('.word-item').forEach(el => {
                          el.classList.remove('solved', 'disabled', 'selected', 'highlight-hint', 'highlight-review');
                          el.style.animation = ''; // Remove shake animation if present
                          // Re-attach listeners temporarily might be complex, easier to just disable all later
                     });

                     let colorIdx = 0;
                     // Assuming solution.groups is an object like { groupKey: { description: "...", words: [], difficulty_index: 0 }, ... }
                     for (const groupKey in solution.groups) {
                           if (Object.hasOwnProperty.call(solution.groups, groupKey)) {
                               const groupData = solution.groups[groupKey];
                               const groupDesc = groupData.description || "Group " + (colorIdx + 1);
                               const groupWords = groupData.words || [];
                               const groupColor = groupData.difficulty_index ?? colorIdx;
                               displaySolvedGroup(groupDesc, groupWords, groupColor); // This also marks words as solved
                               colorIdx++;
                           }
                     }
                     reorderGrid(); // Ensure order
                     clearFeedback();
                     showFeedback('Solution Revealed.', '', 3000);

                } catch (error) {
                    console.error("Failed to reveal solution:", error);
                    showFeedback('Could not load the full solution.', 'feedback-incorrect', 3000);
                } finally {
                    disableAllInteraction(); // Ensure everything is fully disabled after revealing
                     if (newGameBtn.style.display === 'none') { // Show Play Again if needed
                        newGameBtn.style.display = 'flex';
                        newGameBtn.onclick = goToHome;
                     }
                     addPostGameReviewListeners(); // Allow review even after revealing
                }
            }

            function disableAllInteraction() {
                 document.querySelectorAll('.word-item').forEach(el => {
                      el.removeEventListener('click', handleWordClick);
                      el.removeEventListener('keydown', handleWordKeyDown);
                      el.style.cursor = 'default';
                      el.style.animation = ''; // Remove any ongoing animation
                      if (!el.classList.contains('solved')) {
                          el.classList.add('disabled'); // Visually disable non-solved items
                          el.classList.remove('selected');
                          el.setAttribute('aria-selected', 'false');
                      }
                     el.setAttribute('aria-disabled', 'true');
                     el.removeAttribute('tabindex'); // Make non-focusable
                 });
                 clearSelectionBtn.disabled = true;
                 hintBtn.disabled = true;
                 // Remove grid navigation listener if added directly to grid
                 // (If added in setupGridNavigation, it's okay as items are not focusable)
            }

             function enableAllInteraction() {
                 document.querySelectorAll('.word-item:not(.solved)').forEach(el => {
                     el.addEventListener('click', handleWordClick);
                     el.addEventListener('keydown', handleWordKeyDown);
                     el.style.cursor = 'pointer';
                     el.classList.remove('disabled');
                     el.setAttribute('aria-disabled', 'false');
                     el.setAttribute('tabindex', '0'); // Make focusable
                 });
                 updateSelectionUI(); // Update button states
                 // Ensure grid navigation is set up (it's idempotent if called multiple times)
                 setupGridNavigation();
             }

            function goToHome() {
                 sessionStorage.removeItem(PUZZLE_STORAGE_KEY); // Clean up session storage
                 window.location.href = 'home.html'; // Redirect to home page
            }

            // --- Stats Functions ---
            function loadStats() {
                const storedStats = localStorage.getItem(STATS_STORAGE_KEY);
                if (storedStats) {
                    try {
                        const parsedStats = JSON.parse(storedStats);
                        if (typeof parsedStats.wins === 'number' && typeof parsedStats.losses === 'number') {
                            gameStats = { ...gameStats, ...parsedStats }; // Merge safely
                        } else { localStorage.removeItem(STATS_STORAGE_KEY); }
                    } catch (e) { localStorage.removeItem(STATS_STORAGE_KEY); }
                }
            }

            function saveStats() {
                try {
                    localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(gameStats));
                } catch (e) { cons