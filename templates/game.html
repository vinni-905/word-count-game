<!DOCTYPE html>
<html lang="en"> <!-- Theme class added by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordLinks - Play</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        /* --- Base & Typography --- */
        :root { /* Light Theme (Default) */
            --bg-gradient-start: #f8f9fa; --bg-gradient-end: #ffffff;
            --container-bg: #ffffff; --text-primary: #343a40; --text-secondary: #6c757d;
            --accent-primary: #007bff; --accent-secondary: #8f94fb;
            --selected-bg: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%); --selected-text: #ffffff;
            --solved-bg: #e9ecef; --solved-text: #adb5bd; --disabled-opacity: 0.6;
            --correct-bg: #d1e7dd; --correct-text: #0f5132; --correct-border: #badbcc;
            --incorrect-bg: #f8d7da; --incorrect-text: #842029; --incorrect-border: #f5c2c7;
            --hint-bg: #cff4fc; --hint-text: #055160; --hint-border: #b6effb;
            --button-primary-bg: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            --button-primary-hover: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            --button-warning-bg: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            --button-warning-hover: linear-gradient(135deg, #e0a800 0%, #c69500 100%);
            --button-info-bg: linear-gradient(135deg, #17a2b8 0%, #117a8b 100%);
            --button-info-hover: linear-gradient(135deg, #117a8b 0%, #0f6674 100%);
            --button-shuffle-bg: linear-gradient(135deg, #fd7e14 0%, #e85a00 100%);
            --button-shuffle-hover: linear-gradient(135deg, #e85a00 0%, #c54a00 100%);
            --button-success-bg: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            --button-success-hover: linear-gradient(135deg, #1e7e34 0%, #155724 100%);
            --button-disabled-bg: #ced4da; --button-disabled-text: #6c757d;
            --container-border: rgba(255, 255, 255, 0.3); --blur-intensity: 10px;
            --solved-color-0-bg: linear-gradient(135deg, #fefae0 0%, #faedcd 100%);
            --solved-color-0-text: #bc6c25; --solved-color-0-border: #e9c46a;
            --solved-color-1-bg: linear-gradient(135deg, #caf0f8 0%, #ade8f4 100%);
            --solved-color-1-text: #0077b6; --solved-color-1-border: #48cae4;
            --solved-color-2-bg: linear-gradient(135deg, #d8f3dc 0%, #b7e4c7 100%);
            --solved-color-2-text: #2d6a4f; --solved-color-2-border: #74c69d;
            --solved-color-3-bg: linear-gradient(135deg, #fec8d8 0%, #ffacb7 100%);
            --solved-color-3-text: #c9184a; --solved-color-3-border: #ff758f;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1); --shadow-md: 0 4px 8px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.1); --transition-speed: 0.25s;
            --word-item-base-bg: #f8f9fa; --word-item-base-border: #dee2e6;
            --controls-bg: #f8f9fa; --status-bar-bg: #f8f9fa;
            --modal-overlay-bg: rgba(0, 0, 0, 0.6);
            --theme-toggle-btn-color: var(--text-secondary);
            --theme-toggle-btn-hover-color: var(--text-primary);
            --error-message-bg: var(--incorrect-bg); --error-message-text: var(--incorrect-text);
            --error-message-border: var(--incorrect-border);
            --timer-default-color: var(--accent-primary);
            --timer-warning-color: var(--incorrect-text);
            --daily-indicator-bg: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            --daily-indicator-text: var(--accent-primary);
            --leaderboard-header-bg: var(--accent-primary);
            --leaderboard-header-text: white;
            --leaderboard-row-even-bg: #f2f2f2;
            --leaderboard-border-color: #ddd;
        }

        html.dark-theme { /* Dark Theme Overrides */
            --bg-gradient-start: #212529; --bg-gradient-end: #343a40;
            --container-bg: #495057; --text-primary: #f8f9fa; --text-secondary: #adb5bd;
            --accent-primary: #0d6efd;
            --selected-bg: linear-gradient(135deg, #5e31a7 0%, #1a5bbd 100%);
            --solved-bg: #343a40; --solved-text: #6c757d;
            --correct-bg: #14452F; --correct-text: #a3d4b8; --correct-border: #2f6f4f;
            --incorrect-bg: #591C21; --incorrect-text: #f5c2c7; --incorrect-border: #8c222c;
            --hint-bg: #033C4A; --hint-text: #b6effb; --hint-border: #0f6674;
            --button-disabled-bg: #5a6268; --button-disabled-text: #adb5bd;
            --button-shuffle-bg: linear-gradient(135deg, #c4630e 0%, #b04e00 100%);
            --button-shuffle-hover: linear-gradient(135deg, #b04e00 0%, #934000 100%);
            --solved-color-0-bg: linear-gradient(135deg, #4d441e 0%, #443b19 100%);
            --solved-color-0-text: #fefae0; --solved-color-0-border: #8a6d3b;
            --solved-color-1-bg: linear-gradient(135deg, #004c75 0%, #003d5e 100%);
            --solved-color-1-text: #caf0f8; --solved-color-1-border: #006298;
            --solved-color-2-bg: linear-gradient(135deg, #1c4b33 0%, #153826 100%);
            --solved-color-2-text: #d8f3dc; --solved-color-2-border: #255a40;
            --solved-color-3-bg: linear-gradient(135deg, #8a1234 0%, #700f2b 100%);
            --solved-color-3-text: #fec8d8; --solved-color-3-border: #b01742;
            --word-item-base-bg: #3E444A; --word-item-base-border: #5A6268;
            --controls-bg: #343a40; --status-bar-bg: #343a40;
            --modal-overlay-bg: rgba(0, 0, 0, 0.8);
            --theme-toggle-btn-color: var(--text-secondary);
            --theme-toggle-btn-hover-color: var(--text-primary);
            --error-message-bg: var(--incorrect-bg); --error-message-text: var(--incorrect-text);
            --error-message-border: var(--incorrect-border);
            --timer-default-color: #79c0ff;
            --timer-warning-color: #ff848f;
            --daily-indicator-bg: color-mix(in srgb, var(--accent-primary) 30%, transparent);
            --daily-indicator-text: #79c0ff;
            --leaderboard-header-bg: #0b5ed7;
            --leaderboard-header-text: #e9ecef;
            --leaderboard-row-even-bg: #3E444A;
            --leaderboard-border-color: #5A6268;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Poppins', sans-serif; line-height: 1.6;
            background: linear-gradient(to bottom, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-primary); padding: 20px; min-height: 100vh;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; animation: fadeInPage 0.5s ease-out forwards;
            transition: background var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        @keyframes fadeInPage { to { opacity: 1; } }
        body.fade-out { opacity: 1; animation: fadeOutPage 0.3s ease-in forwards; }
        @keyframes fadeOutPage { to { opacity: 0; } }
        .container {
            width: 100%; max-width: 700px; margin: 20px auto;
            background: var(--container-bg); padding: 30px;
            border-radius: 16px; box-shadow: var(--shadow-lg);
            position: relative;
            transition: background-color var(--transition-speed) ease;
        }
        #theme-toggle-btn {
            position: absolute; top: 15px; right: 15px;
            background: none; border: none; font-size: 1.3em; cursor: pointer;
            color: var(--theme-toggle-btn-color); padding: 5px;
            transition: color var(--transition-speed) ease, transform var(--transition-speed) ease;
        }
        #theme-toggle-btn:hover { color: var(--theme-toggle-btn-hover-color); transform: scale(1.1); }
        h1 { text-align: center; color: var(--text-primary); margin-bottom: 5px; font-weight: 700; transition: color var(--transition-speed) ease;}
        .daily-challenge-indicator {
            text-align: center; font-weight: bold; color: var(--daily-indicator-text);
            background-color: var(--daily-indicator-bg);
            padding: 5px 10px; margin-bottom: 10px; margin-top: 5px; border-radius: 6px;
            font-size: 0.9em;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        h2 { text-align: center; color: var(--text-secondary); margin-bottom: 15px; font-weight: 600; font-size: 1em; transition: color var(--transition-speed) ease;}
        .status-bar {
            display: flex; justify-content: space-around; align-items: center;
            padding: 15px 0; margin-bottom: 20px; border-bottom: 1px solid var(--word-item-base-border);
            flex-wrap: wrap; gap: 15px; background-color: var(--status-bar-bg);
            border-radius: 8px; box-shadow: var(--shadow-sm);
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .status-bar div {
            font-weight: 600; font-size: 0.9em; text-align: center;
            flex-basis: auto; flex-grow: 1; color: var(--text-secondary);
            transition: color var(--transition-speed) ease;
        }
        .status-bar span {
            font-weight: 700; color: var(--accent-primary);
            font-size: 1.1em; margin-left: 5px;
            transition: color var(--transition-speed) ease;
        }
        #timer-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #timer {
            min-width: 80px;
            color: var(--timer-default-color);
            transition: color 0.3s ease;
        }
        #timer.countdown-active { font-weight: bold; }
        #timer.countdown-warning { color: var(--timer-warning-color) !important; animation: pulseWarning 1s infinite alternate; }
        @keyframes pulseWarning { from { transform: scale(1); } to { transform: scale(1.05); } }

        #word-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 25px; }
        .word-item {
            background-color: var(--word-item-base-bg); padding: 15px 8px; text-align: center;
            border-radius: 8px; cursor: pointer; font-weight: 600; text-transform: uppercase;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease,
                        transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            user-select: none; min-height: 3.5em; display: flex;
            align-items: center; justify-content: center; line-height: 1.2;
            word-break: break-word; box-shadow: var(--shadow-sm); border: 1px solid var(--word-item-base-border);
            color: var(--text-primary);
        }
        .word-item:hover:not(.selected):not(.solved):not(.disabled) {
             background-color: var(--accent-secondary); color: var(--selected-text);
             transform: translateY(-3px); box-shadow: var(--shadow-md);
        }
        html.dark-theme .word-item:hover:not(.selected):not(.solved):not(.disabled) { background-color: #5f67ee; }
        .word-item:focus-visible, .solved-group.reviewable:focus-visible {
            outline: 3px solid var(--accent-primary); outline-offset: 2px; box-shadow: var(--shadow-md);
        }
        .word-item.selected {
            background: var(--selected-bg); color: var(--selected-text);
            transform: scale(1.05) translateY(-2px); box-shadow: var(--shadow-md); border: none;
        }
        .word-item.solved,
        .word-item.disabled {
            background-color: var(--solved-bg); color: var(--solved-text);
            cursor: default; opacity: var(--disabled-opacity); box-shadow: none;
            border: 1px solid var(--solved-text); transform: none;
        }
        .word-item.correct-match-animation { animation: correctMatchPop 0.6s ease-out forwards; }
        @keyframes correctMatchPop {
            0% { transform: scale(1.05) translateY(-2px); opacity: 1; }
            50% { transform: scale(1.2) translateY(-5px) rotate(3deg); opacity: 0.9; background-color: var(--correct-bg); color: var(--correct-text); }
            100% { transform: scale(1); opacity: 1; }
        }
        .controls {
            text-align: center; margin-bottom: 20px; display: grid;
            grid-template-columns: 1fr auto auto auto;
            align-items: center;
            gap: 10px; padding: 15px; background-color: var(--controls-bg);
            border-radius: 8px; box-shadow: var(--shadow-sm);
            transition: background-color var(--transition-speed) ease;
        }
        .controls p {
            margin: 0; white-space: nowrap; font-size: 0.9em;
            color: var(--text-secondary); text-align: left;
            transition: color var(--transition-speed) ease;
            grid-column: 1 / 2;
        }
        .controls p span { font-weight: 700; color: var(--accent-primary); font-size: 1.1em; transition: color var(--transition-speed) ease;}
        .controls button, .post-game-actions button {
            padding: 10px 18px;
            cursor: pointer; border-radius: 25px;
            border: none; font-weight: 600; font-size: 0.85em;
            color: white;
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm);
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        }
        .controls button:hover:not(:disabled), .post-game-actions button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-md); }
        .controls button:active:not(:disabled), .post-game-actions button:active:not(:disabled) { transform: translateY(0); box-shadow: var(--shadow-sm); }

        #clear-selection-btn { background: var(--button-warning-bg); }
        #clear-selection-btn:hover:not(:disabled) { background: var(--button-warning-hover); }
        #hint-btn { background: var(--button-info-bg); }
        #hint-btn:hover:not(:disabled) { background: var(--button-info-hover); }
        #shuffle-btn { background: var(--button-shuffle-bg); }
        #shuffle-btn:hover:not(:disabled) { background: var(--button-shuffle-hover); }

        .controls button:disabled, .post-game-actions button:disabled {
            background: var(--button-disabled-bg); color: var(--button-disabled-text);
            cursor: not-allowed; box-shadow: none; transform: none;
        }
        #feedback-area {
            margin-top: 15px; margin-bottom: 20px; padding: 15px 20px;
            border-radius: 8px; min-height: 3em; text-align: center; font-weight: 600;
            box-sizing: border-box; display: flex; align-items: center; justify-content: center;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            border: 1px solid transparent;
        }
        .feedback-correct { background-color: var(--correct-bg); color: var(--correct-text); border-color: var(--correct-border); }
        .feedback-incorrect { background-color: var(--incorrect-bg); color: var(--incorrect-text); border-color: var(--incorrect-border); }
        .feedback-hint { background-color: var(--hint-bg); color: var(--hint-text); border-color: var(--hint-border); }
        #solved-groups-area { margin-bottom: 25px; display: grid; grid-template-columns: 1fr; gap: 15px; }
        .solved-group {
            border-radius: 12px; padding: 15px 20px; text-align: center;
            box-shadow: var(--shadow-md); border-width: 2px; border-style: solid;
            transition: transform 0.3s ease-out, opacity 0.5s ease-out, background var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            transform: scale(0.95); opacity: 0; animation: fadeInScale 0.5s ease-out forwards;
        }
        @keyframes fadeInScale { to { opacity: 1; transform: scale(1); } }
        .solved-group.reviewable { cursor: pointer; }
        .solved-group.reviewable:hover { box-shadow: var(--shadow-lg); transform: scale(1.02); }
        .solved-group strong { display: block; margin-bottom: 8px; text-transform: uppercase; font-size: 1em; font-weight: 700; }
        .solved-group p { margin: 0; font-size: 0.95em; font-weight: 400; line-height: 1.5; }
        .solved-group-color-0 { background: var(--solved-color-0-bg); color: var(--solved-color-0-text); border-color: var(--solved-color-0-border); animation-delay: 0s; }
        .solved-group-color-1 { background: var(--solved-color-1-bg); color: var(--solved-color-1-text); border-color: var(--solved-color-1-border); animation-delay: 0.1s; }
        .solved-group-color-2 { background: var(--solved-color-2-bg); color: var(--solved-color-2-text); border-color: var(--solved-color-2-border); animation-delay: 0.2s; }
        .solved-group-color-3 { background: var(--solved-color-3-bg); color: var(--solved-color-3-text); border-color: var(--solved-color-3-border); animation-delay: 0.3s; }
        .word-item.highlight-review {
            background-color: var(--hint-bg) !important; color: var(--hint-text) !important;
            border: 2px solid var(--hint-border) !important; opacity: 1 !important; transform: scale(1.03);
            transition: background-color 0.1s ease-out, color 0.1s ease-out, border-color 0.1s ease-out, transform 0.1s ease-out;
        }
        .word-item.highlight-hint {
            outline: 3px dashed var(--accent-secondary); outline-offset: 2px;
            transition: outline 0.2s ease-out; position: relative; z-index: 5;
        }
        .post-game-actions {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .post-game-actions button {
             flex-grow: 1;
             min-width: 160px;
        }

        #new-game-btn { background: var(--button-success-bg); }
        #new-game-btn:hover:not(:disabled) { background: var(--button-success-hover); }
        #view-solution-btn { background: var(--button-info-bg); }
        #view-solution-btn:hover:not(:disabled) { background: var(--button-info-hover); }
        #view-leaderboard-btn { background: var(--button-primary-bg); }
        #view-leaderboard-btn:hover:not(:disabled) { background: var(--button-primary-hover); }
        #challenge-friend-btn { background: var(--button-warning-bg); color: var(--text-primary); }
        #challenge-friend-btn:hover:not(:disabled) { background: var(--button-warning-hover); }
        html.dark-theme #challenge-friend-btn { color: var(--text-primary); }

        .share-buttons-container {
            display: none;
            flex-basis: 100%;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--word-item-base-border);
            text-align: center;
        }
        .share-buttons-container h4 {
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-weight: 600;
        }
        .social-share-button {
            padding: 8px 15px !important;
            font-size: 0.8em !important;
            margin: 5px !important;
            min-width: auto !important;
            flex-grow: 0 !important;
        }
        #share-twitter-btn { background: #1DA1F2; }
        #share-twitter-btn:hover { background: #0c85d0; }
        #share-linkedin-btn { background: #0A66C2; }
        #share-linkedin-btn:hover { background: #004182; }
        #share-whatsapp-btn { background: #25D366; }
        #share-whatsapp-btn:hover { background: #1DA851; }
        #share-instagram-info-btn {
            background: linear-gradient(45deg, #f09433 0%,#e6683c 25%,#dc2743 50%,#cc2366 75%,#bc1888 100%);
        }
        #share-instagram-info-btn:hover {
            background: linear-gradient(45deg, #d17c22 0%,#c7562b 25%,#ba1e35 50%,#ae1f58 75%,#a21575 100%);
        }
        #copy-summary-btn { background: var(--button-info-bg); }
        #copy-summary-btn:hover { background: var(--button-info-hover); }


        .error-message {
             text-align: center; color: var(--error-message-text); font-style: normal;
             background-color: var(--error-message-bg); border: 1px solid var(--error-message-border);
             padding: 10px 15px; border-radius: 8px; font-weight: 600; margin-top: 15px; margin-bottom: 20px;
             transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        #loading-message, #puzzle-info {
             text-align: center; color: var(--text-secondary);
             font-style: italic; margin-bottom: 15px;
             transition: color var(--transition-speed) ease;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0) scale(1.05) translateY(-2px); }
            20% { transform: translateX(-7px) scale(1.05) translateY(-2px) rotate(-2deg); }
            40% { transform: translateX(7px) scale(1.05) translateY(-2px) rotate(2deg); }
            60% { transform: translateX(-5px) scale(1.05) translateY(-2px) rotate(-1deg); }
            80% { transform: translateX(5px) scale(1.05) translateY(-2px) rotate(1deg); }
        }
        .modal-overlay {
            position: fixed; inset: 0; background-color: var(--modal-overlay-bg);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s, background-color var(--transition-speed) ease;
            overflow-y: auto; /* MODIFIED: Allow overlay to scroll if modal is too tall */
        }
        .modal-overlay.modal-open { opacity: 1; visibility: visible; }
        .modal-content {
            background: var(--container-bg); padding: 30px 40px; border-radius: 15px;
            border: 1px solid var(--container-border); box-shadow: var(--shadow-lg);
            backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity));
            max-width: 450px; width: 90%; text-align: center; color: var(--text-primary);
            transform: scale(0.9);
            transition: transform 0.3s ease, background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            /* Removed overflow-y: auto from general modal content, will be handled by specific inner containers */
        }
        .modal-overlay.modal-open .modal-content { transform: scale(1); }
        .modal-title {
            font-size: 1.5em; font-weight: 700; margin-bottom: 15px;
            display: flex; align-items: center; justify-content: center;
            gap: 10px; color: var(--accent-primary);
            transition: color var(--transition-speed) ease;
        }
        .modal-content p { margin-bottom: 25px; font-size: 1em; line-height: 1.6; color: var(--text-secondary); transition: color var(--transition-speed) ease;}
        .modal-actions { display: flex; justify-content: space-around; gap: 15px; flex-wrap: wrap; }
        .modal-button {
            padding: 10px 25px; cursor: pointer; border-radius: 25px;
            border: 1px solid transparent; font-weight: 600; font-size: 0.9em; color: #fff;
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm); display: flex; align-items: center; gap: 8px;
        }
        .modal-button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: var(--shadow-md); }
        .modal-button:focus-visible { outline: 3px solid var(--accent-primary); outline-offset: 1px; }
        .modal-button-confirm { background: var(--button-success-bg); }
        .modal-button-confirm:hover:not(:disabled) { background: var(--button-success-hover); }
        .modal-button-cancel { background: var(--button-warning-bg); color: var(--text-primary); }
        html.dark-theme .modal-button-cancel { color: var(--text-primary); }
        .modal-button-cancel:hover:not(:disabled) { background: var(--button-warning-hover); }
        .modal-button i { font-size: 1.1em; }

        #player-name-input {
            padding: 10px; border-radius: 5px;
            border: 1px solid #ccc; width: 80%;
            margin-bottom: 20px; font-size: 1em;
            background-color: var(--word-item-base-bg);
            color: var(--text-primary);
        }
        html.dark-theme #player-name-input { border: 1px solid #555; }

        /* Leaderboard Modal Specific Styles - UPDATED for scrolling */
        #leaderboard-modal .modal-content {
            max-width: 650px;
            display: flex; /* Use flexbox for internal layout */
            flex-direction: column; /* Stack children vertically */
            max-height: 85vh; /* Limit height to 85% of viewport height */
        }
        #leaderboard-modal .modal-title {
            flex-shrink: 0; /* Prevent title from shrinking */
        }
        #leaderboard-modal .filters {
            flex-shrink: 0; /* Prevent filters from shrinking */
            margin-bottom: 15px; text-align: center; display: flex;
            flex-wrap: wrap; gap: 10px; justify-content: center; align-items: center;
        }
        #leaderboard-modal .filters label { margin-right: 5px; color: var(--text-secondary); }
        #leaderboard-modal .filters select, #leaderboard-modal #lb-filter-btn {
            padding: 8px; border-radius: 4px; border: 1px solid var(--word-item-base-border);
            background-color: var(--word-item-base-bg); color: var(--text-primary); font-size: 0.9em;
        }
        #leaderboard-modal #lb-filter-btn { background: var(--button-info-bg); color: white; }
        #leaderboard-modal #lb-filter-btn:hover:not(:disabled) { background: var(--button-info-hover); }

        #leaderboard-modal .table-container { /* NEW WRAPPER FOR TABLE */
            flex-grow: 1; /* Allow this to take remaining space */
            overflow-y: auto; /* Make THIS container scrollable */
            margin-bottom: 15px;
        }
        #leaderboard-modal table { width: 100%; border-collapse: collapse; /* Removed margin-top */ }
        #leaderboard-modal th, #leaderboard-modal td {
            border: 1px solid var(--leaderboard-border-color); padding: 8px 10px;
            text-align: left; font-size: 0.9em;
        }
        #leaderboard-modal th {
            background-color: var(--leaderboard-header-bg); color: var(--leaderboard-header-text);
            font-weight: 600;
        }
        #leaderboard-modal tr:nth-child(even) { background-color: var(--leaderboard-row-even-bg); }
        #lb-no-scores-message {
            flex-shrink: 0;
            text-align: center; color: var(--text-secondary); margin-top: 15px;
        }
         #leaderboard-modal .modal-actions {
            flex-shrink: 0; /* Prevent actions from shrinking */
            margin-top: auto; /* Push to bottom if content is short, or use explicit margin if preferred */
            padding-top: 15px; /* Add some space above the close button if table is short */
        }


        @media (max-width: 480px) {
            .modal-content { padding: 20px 25px; } .modal-title { font-size: 1.3em; }
            .modal-actions { flex-direction: column; align-items: center; }
            .modal-button { width: 80%; justify-content: center; }
        }
        @media (max-width: 768px) {
            .container { padding: 20px; } #theme-toggle-btn { top: 10px; right: 10px; }
            h1 { font-size: 1.8em; }
            .status-bar { padding: 10px; } .status-bar div { font-size: 0.85em; } .status-bar span { font-size: 1em; }
            #word-grid { gap: 10px; } .word-item { font-size: 0.9em; min-height: 3.2em; padding: 12px 5px; }
            .controls { grid-template-columns: 1fr; justify-items: center; }
            .controls p { text-align: center; margin-bottom: 10px; grid-column: 1 / -1; }
            .controls button { width: 60%; }
            .controls #shuffle-btn { width: 60%; }
            #leaderboard-modal .modal-content { max-width: 95%; padding: 15px; }
            #leaderboard-modal .filters { flex-direction: column; gap: 8px; }
            #leaderboard-modal .filters select, #leaderboard-modal .filters button { width: 100%; margin-right: 0; }
            #leaderboard-modal th, #leaderboard-modal td { font-size: 0.8em; padding: 6px 8px; }
        }
        @media (max-width: 480px) {
            body { padding: 10px; } .container { padding: 15px; border-radius: 12px; }
            h1 { font-size: 1.5em; margin-bottom: 10px;} h2 { font-size: 1em; margin-bottom: 15px; }
            .status-bar { flex-direction: column; align-items: stretch; gap: 8px; padding: 8px; }
            .status-bar div { text-align: left; padding: 0 10px; }
            #word-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 20px;}
            .word-item { font-size: 0.85em; min-height: 3.5em; font-weight: 600; }
            .controls { grid-template-columns: 1fr 1fr; grid-template-areas: "text text" "b1 b2" "b3 b3"; gap: 8px; }
            .controls p { grid-area: text; margin-bottom: 5px;}
            .controls #shuffle-btn { grid-area: b1; width: 100%; }
            .controls #clear-selection-btn { grid-area: b2; width: 100%;}
            .controls #hint-btn { grid-area: b3; width: 100%; justify-self: center;}
            .post-game-actions button { width: 85%; min-width: unset; }
            #feedback-area { padding: 10px 15px; font-size: 0.9em;}
            .solved-group { padding: 10px 15px; } .solved-group strong { font-size: 0.9em; } .solved-group p { font-size: 0.9em; }
            #leaderboard-modal th, #leaderboard-modal td { font-size: 0.75em; padding: 4px 5px; word-break: break-all; }
        }
    </style>
</head>
<body>
    <!-- Sound effect elements -->
    <audio id="select-sound" src="/static/sounds/select.mp3" preload="auto"></audio>
    <audio id="correct-sound" src="/static/sounds/correct.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="/static/sounds/incorrect.mp3" preload="auto"></audio>
    <audio id="win-sound" src="/static/sounds/win.mp3" preload="auto"></audio>
    <audio id="lose-sound" src="/static/sounds/lose.mp3" preload="auto"></audio>
    <audio id="shuffle-sound" src="/static/sounds/shuffle.mp3" preload="auto"></audio>

    <div class="container game-container">
        <button id="theme-toggle-btn" aria-label="Toggle dark mode">
            <i class="fas fa-moon"></i>
        </button>

        <h1>WordLinks</h1>
        <div id="daily-challenge-indicator" class="daily-challenge-indicator" style="display: none;">
            ðŸŒŸ Daily Challenge ðŸŒŸ
        </div>
        <div class="status-bar">
            <div id="timer-container">
                <span id="timer-label">Time: </span><span id="timer">00:00</span>
            </div>
            <div>Score: <span id="score">1000</span></div>
            <div>Hints: <span id="hints-used">0</span> / <span id="hints-allowed">3</span></div>
            <div>Mistakes: <span id="lives-remaining">4</span></div>
        </div>

        <p id="loading-message">Loading puzzle...</p>
        <p id="error-message" class="error-message" style="display: none;"></p>
        <div id="puzzle-info"></div>

        <div id="solved-groups-area"></div>
        <div id="word-grid" role="grid"></div>

        <div class="controls">
             <p>Selected: <span id="selected-count">0</span> / 4</p>
             <button id="shuffle-btn"><i class="fas fa-random"></i> Shuffle</button>
             <button id="clear-selection-btn" disabled><i class="fas fa-times-circle"></i> Clear</button>
             <button id="hint-btn"><i class="fas fa-lightbulb"></i> Hint</button>
        </div>

        <div id="feedback-area" aria-live="polite" aria-atomic="true"></div>

        <div class="post-game-actions" style="display: none;">
            <button id="challenge-friend-btn">
                <i class="fas fa-user-friends"></i> Challenge Friend
            </button>
            <button id="view-leaderboard-btn">
                <i class="fas fa-trophy"></i> Leaderboard
            </button>
            <button id="view-solution-btn">
                <i class="fas fa-eye"></i> View Solution
            </button>
            <button id="new-game-btn">
                <i class="fas fa-redo"></i> Play Again?
            </button>
            <div class="share-buttons-container" style="display: none;">
                <h4>Share Your Success!</h4>
                <button id="share-twitter-btn" class="social-share-button" title="Share on X (Twitter)">
                    <i class="fab fa-twitter"></i> Share on X
                </button>
                <button id="share-linkedin-btn" class="social-share-button" title="Share on LinkedIn">
                    <i class="fab fa-linkedin-in"></i> Share on LinkedIn
                </button>
                <button id="share-whatsapp-btn" class="social-share-button" title="Share on WhatsApp">
                    <i class="fab fa-whatsapp"></i> Share on WhatsApp
                </button>
                <button id="share-instagram-info-btn" class="social-share-button" title="How to share on Instagram">
                    <i class="fab fa-instagram"></i> Share on Instagram
                </button>
                <button id="copy-summary-btn" class="social-share-button" title="Copy game summary to clipboard">
                    <i class="fas fa-copy"></i> Copy Summary
                </button>
            </div>
        </div>


        <!-- Show Answer Modal (Hints Exhausted) -->
        <div id="show-answer-modal" class="modal-overlay" style="display: none;" role="dialog" aria-labelledby="show-answer-modal-title" aria-modal="true">
            <div class="modal-content">
                <h3 id="show-answer-modal-title" class="modal-title"><i class="fas fa-eye"></i> Hints Exhausted</h3>
                <p>You've used all available hints. Would you like to reveal the solution?</p>
                <div class="modal-actions">
                    <button id="confirm-show-answer-btn" class="modal-button modal-button-confirm">
                        <i class="fas fa-check"></i> Show Answer
                    </button>
                    <button id="cancel-show-answer-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Keep Playing
                    </button>
                </div>
            </div>
        </div>

        <!-- Submit Score Modal -->
        <div id="score-submit-modal" class="modal-overlay" style="display: none;" role="dialog" aria-labelledby="score-submit-modal-title" aria-modal="true">
            <div class="modal-content">
                <h3 id="score-submit-modal-title" class="modal-title"><i class="fas fa-trophy"></i> Submit Your Score!</h3>
                <p>Congratulations! Your final score is <strong id="modal-final-score"></strong>.</p>
                <p>Enter your name for the leaderboard (3-10 characters):</p>
                <input type="text" id="player-name-input" maxlength="10" minlength="3" placeholder="Your Name">
                <div class="modal-actions">
                    <button id="confirm-submit-score-btn" class="modal-button modal-button-confirm">
                        <i class="fas fa-check"></i> Submit Score
                    </button>
                    <button id="cancel-submit-score-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Maybe Later
                    </button>
                </div>
            </div>
        </div>

        <!-- Leaderboard Modal (MODIFIED HTML STRUCTURE FOR SCROLLING) -->
        <div id="leaderboard-modal" class="modal-overlay" style="display: none;" role="dialog" aria-labelledby="leaderboard-modal-title" aria-modal="true">
            <div class="modal-content">
                <h3 id="leaderboard-modal-title" class="modal-title"><i class="fas fa-list-ol"></i> Leaderboard</h3>
                <div class="filters">
                    <label for="lb-difficulty-filter">Difficulty:</label>
                    <select id="lb-difficulty-filter">
                        <option value="">All</option>
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                        <option value="Daily Challenge">Daily Challenge</option>
                    </select>
                    <label for="lb-mode-filter">Mode:</label>
                    <select id="lb-mode-filter">
                        <option value="classic">Classic</option>
                        <option value="countdown">Countdown</option>
                        <option value="challenge">Challenge</option>
                    </select>
                    <button id="lb-filter-btn" class="modal-button">
                        <i class="fas fa-filter"></i> Filter
                    </button>
                </div>
                <div class="table-container"> <!-- NEW WRAPPER FOR SCROLLABLE TABLE -->
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Player</th>
                                <th>Score</th>
                                <th>Time (s)</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboard-modal-body">
                            <!-- Scores will be populated here -->
                        </tbody>
                    </table>
                </div>
                <p id="lb-no-scores-message" style="display: none;">No scores found for the selected filters.</p>
                <div class="modal-actions" style="margin-top: auto; padding-top: 15px;"> <!-- Adjusted for flex layout -->
                    <button id="close-leaderboard-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Close
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        try {
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element Selectors (Grouped for clarity) ---
            const wordGrid = document.getElementById('word-grid');
            const loadingMessage = document.getElementById('loading-message');
            const errorMessage = document.getElementById('error-message');
            const feedbackArea = document.getElementById('feedback-area');
            const solvedGroupsArea = document.getElementById('solved-groups-area');
            const puzzleInfoDiv = document.getElementById('puzzle-info');
            const timerSpan = document.getElementById('timer');
            const timerLabelSpan = document.getElementById('timer-label');
            const scoreSpan = document.getElementById('score');
            const hintsUsedSpan = document.getElementById('hints-used');
            const hintsAllowedSpan = document.getElementById('hints-allowed');
            const livesRemainingSpan = document.getElementById('lives-remaining');
            const selectedCountSpan = document.getElementById('selected-count');
            const shuffleBtn = document.getElementById('shuffle-btn');
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            const hintBtn = document.getElementById('hint-btn');
            const postGameActionsDiv = document.querySelector('.post-game-actions');
            const challengeFriendBtn = document.getElementById('challenge-friend-btn');
            const viewLeaderboardBtn = document.getElementById('view-leaderboard-btn');
            const viewSolutionBtn = document.getElementById('view-solution-btn');
            const newGameBtn = document.getElementById('new-game-btn');
            const showAnswerModal = document.getElementById('show-answer-modal');
            const confirmShowAnswerBtn = document.getElementById('confirm-show-answer-btn');
            const cancelShowAnswerBtn = document.getElementById('cancel-show-answer-btn');
            const scoreSubmitModal = document.getElementById('score-submit-modal');
            const confirmSubmitScoreBtn = document.getElementById('confirm-submit-score-btn');
            const cancelSubmitScoreBtn = document.getElementById('cancel-submit-score-btn');
            const modalFinalScoreSpan = document.getElementById('modal-final-score');
            const playerNameInput = document.getElementById('player-name-input');
            const leaderboardModal = document.getElementById('leaderboard-modal');
            const leaderboardModalBody = document.getElementById('leaderboard-modal-body');
            const closeLeaderboardBtn = document.getElementById('close-leaderboard-btn');
            const lbDifficultyFilter = document.getElementById('lb-difficulty-filter');
            const lbModeFilter = document.getElementById('lb-mode-filter');
            const lbFilterBtn = document.getElementById('lb-filter-btn');
            const lbNoScoresMessage = document.getElementById('lb-no-scores-message');
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const dailyChallengeIndicator = document.getElementById('daily-challenge-indicator');
            const shareButtonsContainer = document.querySelector('.share-buttons-container');
            const shareTwitterBtn = document.getElementById('share-twitter-btn');
            const shareLinkedinBtn = document.getElementById('share-linkedin-btn');
            const shareWhatsappBtn = document.getElementById('share-whatsapp-btn');
            const shareInstagramInfoBtn = document.getElementById('share-instagram-info-btn');
            const copySummaryBtn = document.getElementById('copy-summary-btn');
            const selectSound = document.getElementById('select-sound');
            const correctSound = document.getElementById('correct-sound');
            const incorrectSound = document.getElementById('incorrect-sound');
            const winSound = document.getElementById('win-sound');
            const loseSound = document.getElementById('lose-sound');
            const shuffleSound = document.getElementById('shuffle-sound');

            const STARTING_LIVES = 4;
            const STARTING_SCORE = 1000;
            const INCORRECT_GUESS_PENALTY = 75;
            const HINT_PENALTY = 150;
            const MAX_HINTS = 3;
            const PUZZLE_STORAGE_KEY = 'currentPuzzle';
            const STATS_STORAGE_KEY = 'wordLinksGameStats';
            const THEME_STORAGE_KEY = 'wordLinksTheme';
            const SHUFFLE_PENALTY_SCORE = 25;
            const MAX_SHUFFLES_ALLOWED = 3;
            const POINTS_PER_CORRECT_GROUP = 200;
            const TIME_BONUS_TARGET_SECONDS = 180;
            const TIME_BONUS_PER_SECOND_SAVED = 2;
            const GROUP_STREAK_THRESHOLD = 2;
            const GROUP_STREAK_BONUS_MULTIPLIER = 50;
            const PUZZLE_STREAK_BONUS_PER_STREAK = 100;
            const COUNTDOWN_WIN_BONUS_PER_SECOND = 1;

            let currentPuzzle = null, selectedWords = [], lives = STARTING_LIVES, score = STARTING_SCORE;
            let hintsUsed = 0, revealedGroupsCount = 0, solvedGroupKeys = [], isSubmitting = false;
            let gameActive = false, timerInterval = null, startTime = null, feedbackTimeout = null;
            let gameStats = { wins: 0, losses: 0, currentStreak: 0, maxStreak: 0, fastestTime: null, perfectWins: 0, performance: { easy: { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 }, medium: { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 }, hard: { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 }}};
            let hintHighlightTimeout = null, elementToFocusOnModalClose = null;
            let modalFocusableElements = [], currentOpenModal = null;
            const sunIconClass = 'fa-sun', moonIconClass = 'fa-moon';
            let currentGroupStreak = 0;
            let gameMode = "classic";
            let countdownDuration = 0;
            let timeLeft = 0;
            let isDailyChallenge = false;
            let isChallengeGame = false;
            let shufflesUsed = 0;

            const logger = {
                info: (message, ...optionalParams) => console.log(`[INFO] ${message}`, ...optionalParams),
                warn: (message, ...optionalParams) => console.warn(`[WARN] ${message}`, ...optionalParams),
                error: (message, ...optionalParams) => console.error(`[ERROR] ${message}`, ...optionalParams),
                debug: (message, ...optionalParams) => console.debug(`[DEBUG] ${message}`, ...optionalParams),
            };

            function playSound(soundElement) {
                if (soundElement && typeof soundElement.play === 'function') {
                    soundElement.currentTime = 0;
                    soundElement.play().catch(error => logger.warn("Audio play failed:", soundElement.id, error));
                } else if (soundElement) {
                    logger.warn("Attempted to play sound on a non-playable audio element:", soundElement.id);
                }
            }

            async function initGame() {
                logger.info("initGame started");
                closeModal(showAnswerModal);
                closeModal(scoreSubmitModal);
                closeModal(leaderboardModal);
                if (shareButtonsContainer) shareButtonsContainer.style.display = 'none';
                stopTimer(); gameActive = false;
                loadStats();

                const urlParams = new URLSearchParams(window.location.search);
                const challengeId = urlParams.get('challenge');
                let puzzleDataToLoad = null;
                isChallengeGame = false;

                if (challengeId) {
                    logger.info(`Challenge ID found in URL: ${challengeId}`);
                    showFeedback("Loading challenge puzzle...", "", 0);
                    try {
                        const response = await fetch(`/api/get_challenge_puzzle/${challengeId}`);
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ detail: "Challenge puzzle not found or expired."}));
                            throw new Error(errorData.detail || `Failed to load challenge: ${response.status}`);
                        }
                        puzzleDataToLoad = await response.json();
                        sessionStorage.setItem(PUZZLE_STORAGE_KEY, JSON.stringify(puzzleDataToLoad));
                        sessionStorage.setItem('isChallengeGame', 'true');
                        window.history.replaceState({}, document.title, window.location.pathname);
                        logger.info("Challenge puzzle data loaded:", puzzleDataToLoad);
                        clearFeedback();
                        isChallengeGame = true;
                    } catch (error) {
                        logger.error("Error loading challenge puzzle:", error);
                        showError(`Could not load challenge: ${error.message}. A new random game will be started if available, otherwise please go to Home.`);
                        sessionStorage.removeItem(PUZZLE_STORAGE_KEY);
                        sessionStorage.removeItem('isChallengeGame');
                    }
                }

                isDailyChallenge = sessionStorage.getItem('isDailyChallenge') === 'true' && !isChallengeGame;

                if (isDailyChallenge) {
                    gameMode = "classic";
                    if (dailyChallengeIndicator) dailyChallengeIndicator.style.display = 'block';
                    if (puzzleInfoDiv) puzzleInfoDiv.innerHTML = '';
                } else if (isChallengeGame) {
                    if (dailyChallengeIndicator) dailyChallengeIndicator.style.display = 'none';
                    gameMode = "challenge";
                    if (puzzleInfoDiv && puzzleDataToLoad) {
                         puzzleInfoDiv.innerHTML = `<p style="font-style:italic; color: var(--accent-secondary);">Playing a Challenge Puzzle! (Originally ${puzzleDataToLoad.difficulty || 'Unknown'} difficulty)</p>`;
                    }
                } else {
                    if (dailyChallengeIndicator) dailyChallengeIndicator.style.display = 'none';
                    gameMode = sessionStorage.getItem('gameMode') || "classic";
                }

                if (gameMode === "countdown" && !isDailyChallenge && !isChallengeGame) {
                    countdownDuration = parseInt(sessionStorage.getItem('countdownDuration'), 10) || 180;
                    timeLeft = countdownDuration;
                    if(timerLabelSpan) timerLabelSpan.textContent = "Time Left: ";
                    if(timerSpan) { timerSpan.classList.add('countdown-active'); timerSpan.classList.remove('countdown-warning'); timerSpan.style.color = ''; }
                } else {
                    if(timerLabelSpan) timerLabelSpan.textContent = "Time: ";
                    if(timerSpan) { timerSpan.classList.remove('countdown-active', 'countdown-warning'); timerSpan.style.color = ''; }
                }

                score = STARTING_SCORE;
                if (gameStats.currentStreak > 0 && gameMode === "classic" && !isDailyChallenge && !isChallengeGame) {
                    const puzzleStreakBonus = gameStats.currentStreak * PUZZLE_STREAK_BONUS_PER_STREAK;
                    score += puzzleStreakBonus;
                }

                const puzzleDataString = sessionStorage.getItem(PUZZLE_STORAGE_KEY);
                if (!puzzleDataString) {
                    showError('No puzzle data. Go to Home to start.');
                    if(loadingMessage) loadingMessage.style.display = 'none';
                    disableAllInteraction();
                    if (postGameActionsDiv) { postGameActionsDiv.style.display = 'flex'; }
                    if (newGameBtn) { newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome; }
                    if (viewLeaderboardBtn) viewLeaderboardBtn.style.display = 'inline-flex';
                    if (viewSolutionBtn) viewSolutionBtn.style.display = 'none';
                    if (challengeFriendBtn) challengeFriendBtn.style.display = 'none';
                    return;
                }

                try {
                    currentPuzzle = JSON.parse(puzzleDataString);
                    if (!currentPuzzle || !currentPuzzle.words || !currentPuzzle.puzzle_id) throw new Error("Invalid puzzle data format from storage.");

                    lives = STARTING_LIVES; hintsUsed = 0;
                    selectedWords = []; solvedGroupKeys = []; revealedGroupsCount = 0; isSubmitting = false;
                    currentGroupStreak = 0; shufflesUsed = 0;

                    if(clearFeedback && !challengeId) { clearFeedback(); }
                    if(solvedGroupsArea) solvedGroupsArea.innerHTML = '';
                    if(errorMessage) { errorMessage.style.display = 'none'; errorMessage.textContent = ''; }
                    if(loadingMessage) loadingMessage.style.display = 'none';
                    if(wordGrid) wordGrid.innerHTML = '';

                    if (puzzleInfoDiv && !isChallengeGame && !isDailyChallenge) {
                        puzzleInfoDiv.innerHTML = '';
                        if (currentPuzzle.difficulty || (currentPuzzle.puzzle_id && !currentPuzzle.puzzle_id.startsWith("daily_"))) {
                             const infoP = document.createElement('p'); let infoText = [];
                             if(currentPuzzle.puzzle_id && !currentPuzzle.puzzle_id.startsWith("daily_") && currentPuzzle.puzzle_id.length > 8) {
                                 infoText.push(`Puzzle #${currentPuzzle.puzzle_id.substring(0,8)}...`);
                             } else if (currentPuzzle.puzzle_id && !currentPuzzle.puzzle_id.startsWith("daily_")) {
                                 infoText.push(`Puzzle #${currentPuzzle.puzzle_id}`);
                             }
                             if(currentPuzzle.difficulty) infoText.push(`Difficulty: ${currentPuzzle.difficulty}`);
                             if(infoText.length > 0) infoP.textContent = infoText.join(' | ');
                             puzzleInfoDiv.appendChild(infoP);
                        }
                    } else if (!isChallengeGame && !isDailyChallenge && puzzleInfoDiv) {
                        puzzleInfoDiv.innerHTML = '';
                    }

                    displayWords(currentPuzzle.words);
                    updateScoreDisplay(); updateLivesDisplay(); updateHintsDisplay(); updateSelectionUI();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'none';
                    enableAllInteraction(); startTime = Date.now();
                    startTimer();
                    gameActive = true;
                    setInitialFocus();
                } catch (error) {
                    logger.error("Error initializing game from puzzle data:", error);
                    showError(`Failed to load puzzle: ${error.message}. Please try starting a new game from Home.`);
                    if(loadingMessage) loadingMessage.style.display = 'none'; disableAllInteraction();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'flex';
                    if (newGameBtn) { newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome; }
                }
                logger.info("initGame finished");
            }

            function displayWords(words) {
                if(!wordGrid) return;
                wordGrid.innerHTML = '';
                const wordsArray = Array.isArray(words) ? words : [];
                const shuffledWords = [...wordsArray].sort(() => Math.random() - 0.5);
                shuffledWords.forEach((word) => {
                    const wordDiv = document.createElement('div');
                    wordDiv.classList.add('word-item');
                    wordDiv.textContent = word;
                    wordDiv.dataset.word = word;
                    wordDiv.setAttribute('role', 'gridcell');
                    wordDiv.setAttribute('aria-selected', 'false');
                    wordDiv.tabIndex = 0;
                    wordDiv.addEventListener('click', handleWordClick);
                    wordDiv.addEventListener('keydown', handleWordKeyDown);
                    wordGrid.appendChild(wordDiv);
                });
            }

            function updateSelectionUI() {
                if(selectedCountSpan) selectedCountSpan.textContent = selectedWords.length;
                if(clearSelectionBtn) clearSelectionBtn.disabled = selectedWords.length === 0 || isSubmitting || !gameActive;
                if(hintBtn) hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
                if (shuffleBtn) {
                    shuffleBtn.disabled = isSubmitting || !gameActive || revealedGroupsCount === 4 || lives <= 0 || shufflesUsed >= MAX_SHUFFLES_ALLOWED;
                }
            }

            function updateLivesDisplay() {
                 if(!livesRemainingSpan) return;
                 livesRemainingSpan.textContent = lives;
                 const livesDiv = livesRemainingSpan.closest('div');
                 if(livesDiv) {
                    livesDiv.style.color = lives <= 1 ? 'var(--timer-warning-color)' : 'var(--text-secondary)';
                    livesRemainingSpan.style.color = lives <= 1 ? 'var(--timer-warning-color)' : 'var(--accent-primary)';
                 }
            }

            function updateScoreDisplay() { if(scoreSpan) scoreSpan.textContent = Math.max(0, score); }

            function updateHintsDisplay() {
                 if(hintsUsedSpan) hintsUsedSpan.textContent = hintsUsed;
                 if(hintsAllowedSpan) hintsAllowedSpan.textContent = MAX_HINTS;
                 if(hintBtn) hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
            }

            function startTimer() {
                stopTimer();
                if (gameMode === "countdown" && !isDailyChallenge && !isChallengeGame) {
                    if(timerSpan) {
                        timerSpan.classList.add('countdown-active');
                        timerSpan.classList.remove('countdown-warning');
                        timerSpan.style.color = '';
                    }
                    timeLeft = countdownDuration;
                    updateTimerDisplay();
                    timerInterval = setInterval(() => {
                        if (!gameActive) return;
                        timeLeft--;
                        updateTimerDisplay();
                        if (timeLeft <= 10 && timeLeft > 0) {
                            if(timerSpan) timerSpan.classList.add('countdown-warning');
                        } else if (timeLeft <= 0) {
                            stopTimer();
                            showFeedback("Time's up! Puzzle failed.", 'feedback-incorrect', 0);
                            playSound(loseSound);
                            endGame(false);
                        }
                    }, 1000);
                } else {
                    if(timerSpan) {
                        timerSpan.classList.remove('countdown-active', 'countdown-warning');
                        timerSpan.style.color = '';
                    }
                    timerInterval = setInterval(() => {
                        if (!gameActive || !startTime) return;
                        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                        const minutes = Math.floor(elapsedSeconds / 60);
                        const seconds = elapsedSeconds % 60;
                        if(timerSpan) timerSpan.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    }, 1000);
                }
            }

            function updateTimerDisplay() {
                if (gameMode === "countdown" && timerSpan) {
                    const minutes = Math.floor(Math.max(0, timeLeft) / 60);
                    const seconds = Math.max(0, timeLeft) % 60;
                    timerSpan.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }
            function stopTimer() { clearInterval(timerInterval); timerInterval = null; }

            function handleWordClick(event) {
                 const wordDiv = event.currentTarget;
                 if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                 toggleWordSelection(wordDiv);
            }
            function handleWordKeyDown(event) {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault(); const wordDiv = event.currentTarget;
                    if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                    toggleWordSelection(wordDiv);
                }
            }
            function toggleWordSelection(wordDiv) {
                 const word = wordDiv.dataset.word;
                 const isSelected = wordDiv.classList.contains('selected');
                 clearFeedback();
                 if (isSelected) {
                      selectedWords = selectedWords.filter(w => w !== word);
                      wordDiv.classList.remove('selected'); wordDiv.setAttribute('aria-selected', 'false');
                 } else {
                      if (selectedWords.length < 4) {
                           selectedWords.push(word); wordDiv.classList.add('selected');
                           wordDiv.setAttribute('aria-selected', 'true');
                           playSound(selectSound);
                      }
                 }
                 updateSelectionUI();
                 if (selectedWords.length === 4) setTimeout(submitGroupAttempt, 150);
            }

            function clearSelection() {
                 clearFeedback(); selectedWords = [];
                 if (wordGrid) {
                    wordGrid.querySelectorAll('.word-item.selected').forEach(el => {
                        el.classList.remove('selected'); el.setAttribute('aria-selected', 'false');
                    });
                 }
                 updateSelectionUI();
            }

            async function handleHintClick() {
                if (!gameActive || isSubmitting || hintsUsed >= MAX_HINTS || lives <= 0) return;
                isSubmitting = true; updateSelectionUI();
                score -= HINT_PENALTY; hintsUsed++;
                updateScoreDisplay(); updateHintsDisplay(); clearFeedback();
                try {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const response = await fetch('/api/get_hint', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ puzzle_id: currentPuzzle.puzzle_id, solved_group_keys: solvedGroupKeys }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: `HTTP error ${response.status}` }));
                        throw new Error(errorData.detail || `Hint Error: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.hint && result.words && Array.isArray(result.words)) {
                        showFeedback(result.hint, 'feedback-hint', 5000); highlightHintWords(result.words);
                        if (hintsUsed >= MAX_HINTS) { isSubmitting = false; updateSelectionUI(); setTimeout(() => openModal(showAnswerModal), 1000); }
                        else { isSubmitting = false; updateSelectionUI(); }
                    } else if (result.hint) {
                         showFeedback(result.hint, 'feedback-hint', hintsUsed >= MAX_HINTS ? 5000 : 4000);
                         if (hintsUsed >= MAX_HINTS) { isSubmitting = false; updateSelectionUI(); setTimeout(() => openModal(showAnswerModal), 1000); }
                         else { isSubmitting = false; updateSelectionUI(); }
                    } else {
                        showFeedback(result.message || "No hint available.", '', 3000);
                        if (hintsUsed > 0) { hintsUsed--; score += HINT_PENALTY; updateScoreDisplay(); updateHintsDisplay(); }
                        isSubmitting = false; updateSelectionUI();
                    }
                } catch (error) {
                    logger.error('Error getting hint:', error);
                    showFeedback(`Hint Failed: ${error.message}`, 'feedback-incorrect', 4000);
                    if (hintsUsed > 0) { hintsUsed--; score += HINT_PENALTY; }
                    updateScoreDisplay(); updateHintsDisplay(); isSubmitting = false; updateSelectionUI();
                }
            }
            function highlightHintWords(wordsArray) {
                if (hintHighlightTimeout) clearTimeout(hintHighlightTimeout);
                document.querySelectorAll('.word-item.highlight-hint').forEach(el => el.classList.remove('highlight-hint'));
                if (!wordsArray || wordsArray.length === 0 || !wordGrid) return;
                wordsArray.forEach(word => {
                    const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word.toUpperCase()}"]:not(.solved)`);
                    if (wordDiv) wordDiv.classList.add('highlight-hint');
                });
                hintHighlightTimeout = setTimeout(() => {
                    document.querySelectorAll('.word-item.highlight-hint').forEach(el => el.classList.remove('highlight-hint'));
                    hintHighlightTimeout = null;
                }, 5000);
            }

            function clearFeedback() {
                if (feedbackTimeout) clearTimeout(feedbackTimeout); feedbackTimeout = null;
                if (feedbackArea) {
                    feedbackArea.textContent = ''; feedbackArea.className = 'feedback-area';
                }
            }
            function showFeedback(message, className = '', duration = 3000) {
                 if (!feedbackArea) return; clearFeedback();
                 feedbackArea.textContent = message;
                 if (className) feedbackArea.classList.add(className);
                 if (duration > 0) {
                     feedbackTimeout = setTimeout(() => {
                         if (feedbackArea && feedbackArea.textContent === message) clearFeedback();
                     }, duration);
                 }
            }
            function showError(message) { if(errorMessage) {errorMessage.textContent = message; errorMessage.style.display = 'block';}}

            async function submitGroupAttempt() {
                if (!gameActive || isSubmitting || selectedWords.length !== 4 || lives <= 0) return;
                isSubmitting = true; updateSelectionUI(); clearFeedback(); showFeedback('Checking...', '', 0);
                const attemptPayload = { puzzle_id: currentPuzzle.puzzle_id, groups: { 'attempt': selectedWords } };
                await new Promise(resolve => setTimeout(resolve, 300));
                try {
                    const response = await fetch('/api/check_answer', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(attemptPayload)
                    });
                    if (!response.ok) {
                        let errorText = `Check Error: ${response.status}`;
                        try { const errorData = await response.json(); errorText = errorData.detail || errorText; } catch (e) {}
                        throw new Error(errorText);
                    }
                    const result = await response.json(); handleAttemptResult(result);
                } catch (error) {
                     logger.error('Error submitting answer:', error);
                     showFeedback(`Failed to check answer: ${error.message}. Try again.`, 'feedback-incorrect', 4000);
                     clearSelection();
                } finally { isSubmitting = false; updateSelectionUI(); }
            }

            function handleAttemptResult(result) {
                 let foundCorrectGroup = false; let correctGroupDescription = "";
                 let newlySolvedKey = null; let difficultyIndex = revealedGroupsCount;
                 const currentResultSolvedKeys = Object.keys(result.solved_groups || {});
                 const justSolvedKeys = currentResultSolvedKeys.filter(key => !solvedGroupKeys.includes(key));

                 if (justSolvedKeys.length > 0) {
                     foundCorrectGroup = true; newlySolvedKey = justSolvedKeys[0];
                     const solvedGroupData = result.solved_groups[newlySolvedKey];
                      if (typeof solvedGroupData === 'object' && solvedGroupData !== null) {
                         correctGroupDescription = solvedGroupData.description || "Group Found";
                         difficultyIndex = solvedGroupData.difficulty_index !== undefined ? solvedGroupData.difficulty_index : revealedGroupsCount;
                      } else if (typeof solvedGroupData === 'string') { correctGroupDescription = solvedGroupData; }
                     if (!solvedGroupKeys.includes(newlySolvedKey)) solvedGroupKeys.push(newlySolvedKey);
                 }

                  if (foundCorrectGroup) {
                       playSound(correctSound);
                       score += POINTS_PER_CORRECT_GROUP;
                       currentGroupStreak++;

                       if (currentGroupStreak >= GROUP_STREAK_THRESHOLD) {
                           const groupStreakBonus = (currentGroupStreak - (GROUP_STREAK_THRESHOLD - 1)) * GROUP_STREAK_BONUS_MULTIPLIER;
                           score += groupStreakBonus;
                           showFeedback(`Correct! ðŸ”¥ Group Streak x${currentGroupStreak}! +${groupStreakBonus}pts!`, 'feedback-correct', 2500);
                       } else {
                           showFeedback(result.message || "Correct!", 'feedback-correct', 1500);
                       }
                       updateScoreDisplay();
                       const wordsInSolvedGroupForAnim = selectedWords.slice();
                       wordsInSolvedGroupForAnim.forEach(word => {
                           const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]`);
                           if (wordDiv) {
                               wordDiv.classList.add('correct-match-animation');
                               wordDiv.addEventListener('animationend', () => wordDiv.classList.remove('correct-match-animation'), { once: true });
                           }
                       });
                       setTimeout(() => {
                           displaySolvedGroup(correctGroupDescription, wordsInSolvedGroupForAnim, difficultyIndex);
                           revealedGroupsCount++; selectedWords = []; updateSelectionUI();
                           if (revealedGroupsCount === 4) {
                                setTimeout(() => {
                                    showFeedback("Congratulations! Puzzle Solved!", 'feedback-correct', 0);
                                    playSound(winSound); endGame(true);
                                }, 300);
                           }
                       }, 600);
                  } else {
                       playSound(incorrectSound);
                       currentGroupStreak = 0;
                       score -= INCORRECT_GUESS_PENALTY;
                       lives--;
                       updateScoreDisplay(); updateLivesDisplay();
                       showFeedback(result.message || "Incorrect. Try again.", 'feedback-incorrect', 1800);
                       shakeWords();
                       if (lives <= 0) {
                            setTimeout(() => {
                                showFeedback("Game Over! You're out of mistakes.", 'feedback-incorrect', 0);
                                playSound(loseSound); endGame(false);
                            }, 600);
                       } else { setTimeout(clearSelection, 800); }
                  }
            }

            function displaySolvedGroup(description, wordsInGroup, colorIndex) {
                 if(!solvedGroupsArea || !wordGrid) return;
                 const groupDiv = document.createElement('div'); groupDiv.classList.add('solved-group');
                 const actualColorIndex = Math.min(Math.max(colorIndex, 0), 3);
                 groupDiv.classList.add(`solved-group-color-${actualColorIndex}`);
                 groupDiv.dataset.words = JSON.stringify(wordsInGroup.map(w => w.toUpperCase()));
                 groupDiv.setAttribute('tabindex', '0');

                 const descStrong = document.createElement('strong'); descStrong.textContent = description; groupDiv.appendChild(descStrong);
                 const wordsP = document.createElement('p'); wordsP.textContent = wordsInGroup.sort().join(', '); groupDiv.appendChild(wordsP);

                 if (solvedGroupsArea.firstChild) solvedGroupsArea.insertBefore(groupDiv, solvedGroupsArea.firstChild);
                 else solvedGroupsArea.appendChild(groupDiv);

                 wordsInGroup.forEach(word => {
                       const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]`);
                       if (wordDiv) {
                            wordDiv.classList.add('solved');
                            wordDiv.classList.remove('selected', 'highlight-hint', 'correct-match-animation');
                            wordDiv.removeEventListener('click', handleWordClick);
                            wordDiv.removeEventListener('keydown', handleWordKeyDown);
                            wordDiv.style.cursor = 'default';
                            wordDiv.setAttribute('aria-selected', 'false');
                            wordDiv.setAttribute('aria-disabled', 'true');
                            wordDiv.removeAttribute('tabindex');
                       }
                  });
                 reorderGrid();
                 if (revealedGroupsCount < 4) setInitialFocus();
            }

            function reorderGrid() {
                if(!wordGrid) return;
                const solvedItems = Array.from(wordGrid.querySelectorAll('.word-item.solved'));
                const activeItems = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved)'));
                wordGrid.innerHTML = '';
                activeItems.forEach(item => wordGrid.appendChild(item));
                solvedItems.forEach(item => wordGrid.appendChild(item));
            }
            function shakeWords() {
                 document.querySelectorAll('.word-item.selected').forEach(div => {
                      div.style.animation = 'none'; void div.offsetWidth;
                      div.style.animation = 'shake 0.5s ease-in-out';
                 });
            }

            function shuffleWordGrid() {
                if (!gameActive || isSubmitting || shufflesUsed >= MAX_SHUFFLES_ALLOWED) {
                    if (shufflesUsed >= MAX_SHUFFLES_ALLOWED) {
                        showFeedback("No more shuffles allowed.", "", 2000);
                    }
                    return;
                }
                if (selectedWords.length > 0) clearSelection();
                clearFeedback();

                const activeWordDivs = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved)'));
                const activeWordsData = activeWordDivs.map(div => div.dataset.word);
                activeWordsData.sort(() => Math.random() - 0.5);

                activeWordDivs.forEach((div, index) => {
                    div.textContent = activeWordsData[index];
                    div.dataset.word = activeWordsData[index];
                });

                shufflesUsed++;
                score -= SHUFFLE_PENALTY_SCORE;
                updateScoreDisplay();
                updateSelectionUI();

                playSound(shuffleSound);
                showFeedback(`Words shuffled! (${MAX_SHUFFLES_ALLOWED - shufflesUsed} shuffles left)`, "", 2000);
                setInitialFocus();
            }

            function endGame(isWin) {
                 if (!gameActive) return; gameActive = false;
                 stopTimer(); disableAllInteraction();
                 closeModal(showAnswerModal);
                 closeModal(scoreSubmitModal);
                 closeModal(leaderboardModal);

                 const endTime = Date.now();
                 const solveTimeSeconds = startTime ? Math.floor((endTime - startTime) / 1000) : null;

                 if (isWin) {
                    if (gameMode === "classic" && !isDailyChallenge && !isChallengeGame) {
                        let timeBonus = 0;
                        if (solveTimeSeconds !== null && solveTimeSeconds < TIME_BONUS_TARGET_SECONDS) {
                            timeBonus = (TIME_BONUS_TARGET_SECONDS - solveTimeSeconds) * TIME_BONUS_PER_SECOND_SAVED;
                            score += timeBonus;
                        }
                    } else if (gameMode === "countdown" && !isDailyChallenge && !isChallengeGame) {
                        if (timeLeft > 0) { score += timeLeft * COUNTDOWN_WIN_BONUS_PER_SECOND; }
                    }
                 }
                 score = Math.max(0, score); updateScoreDisplay();

                 if (!isDailyChallenge && !isChallengeGame && currentPuzzle && currentPuzzle.difficulty) {
                    const diffKey = currentPuzzle.difficulty.toLowerCase();
                    gameStats.performance[diffKey] = gameStats.performance[diffKey] || { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 };
                    const perf = gameStats.performance[diffKey];
                    perf.plays++;
                    perf.totalHints += hintsUsed;
                    perf.totalMistakes += (STARTING_LIVES - lives);
                    if (solveTimeSeconds !== null) { perf.totalTime += solveTimeSeconds; }

                    if (isWin) {
                        perf.wins++;
                        gameStats.wins++; gameStats.currentStreak++;
                        gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                        if (gameMode === "classic" && solveTimeSeconds !== null && (gameStats.fastestTime === null || solveTimeSeconds < gameStats.fastestTime)) {
                            gameStats.fastestTime = solveTimeSeconds;
                        }
                        if (hintsUsed === 0 && lives === STARTING_LIVES) {
                            gameStats.perfectWins++;
                            setTimeout(() => showFeedback("Flawless Victory! Perfect Game! âœ¨", "feedback-correct", 4000), 1500);
                        }
                    } else {
                        gameStats.losses++; gameStats.currentStreak = 0;
                    }
                    saveStats();
                 } else if (isWin && isDailyChallenge) {
                     logger.info(`Daily challenge ${currentPuzzle?.puzzle_id} completed successfully!`);
                 } else if (!isWin && !isDailyChallenge && !isChallengeGame) {
                    gameStats.losses++; gameStats.currentStreak = 0;
                    saveStats();
                 }

                if (postGameActionsDiv) postGameActionsDiv.style.display = 'flex';
                if (newGameBtn) newGameBtn.style.display = 'inline-flex';
                if (viewSolutionBtn) { viewSolutionBtn.style.display = 'inline-flex'; viewSolutionBtn.disabled = false; viewSolutionBtn.innerHTML = '<i class="fas fa-eye"></i> View Solution'; }
                if (viewLeaderboardBtn) viewLeaderboardBtn.style.display = 'inline-flex';
                if (challengeFriendBtn) {
                    challengeFriendBtn.style.display = (!isDailyChallenge && !isChallengeGame && currentPuzzle) ? 'inline-flex' : 'none';
                }
                if (shareButtonsContainer) {
                    shareButtonsContainer.style.display = (isWin && score > 0 && !isDailyChallenge && !isChallengeGame) ? 'block' : 'none';
                }

                if (isWin && !isDailyChallenge && !isChallengeGame && score > 0) {
                    openModal(scoreSubmitModal, playerNameInput);
                }
                addPostGameReviewListeners();
            }

            function showChallengeLink() {
                if (currentPuzzle && currentPuzzle.puzzle_id) {
                    const challengeId = currentPuzzle.puzzle_id;
                    const gamePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf("/") + 1) + "game";
                    const challengeUrl = `${window.location.origin}${gamePath}?challenge=${challengeId}`;

                    feedbackArea.innerHTML = `
                        <div style="text-align: center;">
                            <p style="margin-bottom: 5px; font-weight:bold;">Share this Challenge!</p>
                            <p style="font-size:0.9em; margin-bottom:3px;">Code: <strong id="challenge-display-code" style="user-select:all;">${challengeId}</strong></p>
                            <p style="font-size:0.9em; margin-bottom:10px;">Link: <input type="text" value="${challengeUrl}" id="challenge-display-link" readonly style="width:80%; padding:5px; font-size:0.9em; border:1px solid var(--word-item-base-border); background:var(--word-item-base-bg); color:var(--text-primary); text-align:center;"></p>
                            <button id="copy-challenge-code-btn" class="modal-button" style="font-size:0.8em; padding: 6px 12px; margin-right: 5px; background: var(--button-info-bg);"><i class="fas fa-copy"></i> Copy Code</button>
                            <button id="copy-challenge-link-btn" class="modal-button" style="font-size:0.8em; padding: 6px 12px; background: var(--button-info-bg);"><i class="fas fa-link"></i> Copy Link</button>
                        </div>
                    `;
                    feedbackArea.className = 'feedback-hint';
                    if (feedbackArea.style.display === 'none') feedbackArea.style.display = 'flex';

                    const copyLinkBtn = document.getElementById('copy-challenge-link-btn');
                    if (copyLinkBtn) {
                        copyLinkBtn.onclick = () => {
                            navigator.clipboard.writeText(challengeUrl)
                                .then(() => showFeedback("Challenge link copied!", "", 2000))
                                .catch(err => { logger.error('Failed to copy link: ', err); showFeedback("Failed to copy link.", "feedback-incorrect", 2000); });
                        };
                    }
                    const copyCodeBtn = document.getElementById('copy-challenge-code-btn');
                     if (copyCodeBtn) {
                        copyCodeBtn.onclick = () => {
                            navigator.clipboard.writeText(challengeId)
                                .then(() => showFeedback("Challenge code copied!", "", 2000))
                                .catch(err => { logger.error('Failed to copy code: ', err); showFeedback("Failed to copy code.", "feedback-incorrect", 2000);});
                        };
                    }
                    const challengeDisplayLink = document.getElementById('challenge-display-link');
                    if(challengeDisplayLink) challengeDisplayLink.onclick = () => challengeDisplayLink.select();
                } else {
                    showFeedback("Could not generate challenge link. Puzzle not available.", "feedback-incorrect", 3000);
                }
            }

            async function revealAllGroups() {
                if (!currentPuzzle?.puzzle_id) return;
                if (gameActive) { gameActive = false; stopTimer(); }
                clearFeedback(); showFeedback('Revealing solution...', '', 0);
                try {
                     await new Promise(resolve => setTimeout(resolve, 400));
                     const response = await fetch(`/api/get_solution/${currentPuzzle.puzzle_id}`);
                     if (!response.ok) throw new Error('Could not fetch solution from server.');
                     const solution = await response.json();
                     if (!solution || !solution.groups || typeof solution.groups !== 'object') {
                        throw new Error("Invalid solution format received from server.");
                     }
                     if(solvedGroupsArea) solvedGroupsArea.innerHTML = '';
                     if(wordGrid) wordGrid.querySelectorAll('.word-item').forEach(el => {
                          el.classList.remove('solved', 'disabled', 'selected', 'highlight-hint', 'highlight-review', 'correct-match-animation');
                          el.style.animation = '';
                     });
                     let colorIdx = 0;
                     if (typeof solution.groups === 'object' && solution.groups !== null) {
                        for (const groupKey in solution.groups) {
                            if (Object.hasOwnProperty.call(solution.groups, groupKey)) {
                                const groupData = solution.groups[groupKey];
                                const groupDesc = groupData.description || "Group " + (colorIdx + 1);
                                const groupWords = groupData.words || [];
                                const groupColor = groupData.difficulty_index ?? colorIdx;
                                displaySolvedGroup(groupDesc, groupWords, groupColor);
                                colorIdx++;
                            }
                        }
                     } else {
                        logger.error("Solution.groups is not an object:", solution.groups);
                        throw new Error("Malformed solution data from server.");
                     }
                     reorderGrid(); clearFeedback(); showFeedback('Solution Revealed.', '', 3000);
                } catch (error) {
                    logger.error("Failed to reveal solution:", error);
                    showFeedback(`Could not load the full solution: ${error.message}`, 'feedback-incorrect', 3000);
                } finally {
                    disableAllInteraction();
                    if (viewSolutionBtn && viewSolutionBtn.innerHTML.includes('Revealing...')) {
                         viewSolutionBtn.innerHTML = '<i class="fas fa-check"></i> Solution Shown';
                         viewSolutionBtn.disabled = true;
                    }
                    addPostGameReviewListeners();
                }
            }
            function disableAllInteraction() {
                 if(wordGrid) wordGrid.removeEventListener('keydown', actualGridNavigationHandler);
                 document.querySelectorAll('.word-item').forEach(el => {
                      el.removeEventListener('click', handleWordClick); el.removeEventListener('keydown', handleWordKeyDown);
                      el.style.cursor = 'default'; el.style.animation = '';
                      if (!el.classList.contains('solved')) {
                          el.classList.add('disabled'); el.classList.remove('selected');
                          el.setAttribute('aria-selected', 'false');
                      }
                     el.setAttribute('aria-disabled', 'true'); el.removeAttribute('tabindex');
                 });
                 if(clearSelectionBtn) clearSelectionBtn.disabled = true;
                 if(hintBtn) hintBtn.disabled = true;
                 if(shuffleBtn) shuffleBtn.disabled = true;
            }
            function enableAllInteraction() {
                 document.querySelectorAll('.word-item:not(.solved)').forEach(el => {
                     el.addEventListener('click', handleWordClick); el.addEventListener('keydown', handleWordKeyDown);
                     el.style.cursor = 'pointer'; el.classList.remove('disabled');
                     el.setAttribute('aria-disabled', 'false'); el.setAttribute('tabindex', '0');
                 });
                 updateSelectionUI(); setupGridNavigation();
            }
            function goToHome() {
                sessionStorage.removeItem(PUZZLE_STORAGE_KEY);
                sessionStorage.removeItem('gameMode');
                sessionStorage.removeItem('countdownDuration');
                sessionStorage.removeItem('isDailyChallenge');
                sessionStorage.removeItem('isChallengeGame');
                document.body.classList.add('fade-out');
                setTimeout(() => { window.location.href = '/home.html'; }, 300);
            }
            function loadStats() {
                const storedStats = localStorage.getItem(STATS_STORAGE_KEY);
                let defaultPerformanceSub = { plays: 0, wins: 0, totalHints: 0, totalMistakes: 0, totalTime: 0 };
                let defaultStatsVal = {
                    wins: 0, losses: 0, currentStreak: 0, maxStreak: 0, fastestTime: null, perfectWins: 0,
                    performance: {
                        easy: { ...defaultPerformanceSub },
                        medium: { ...defaultPerformanceSub },
                        hard: { ...defaultPerformanceSub }
                    }
                }; // Renamed to avoid conflict with gameStats global
                if (storedStats) {
                    try {
                        const parsedStats = JSON.parse(storedStats);
                        gameStats = { // Assign to global gameStats
                            ...defaultStatsVal,
                            ...parsedStats,
                            performance: {
                                easy: { ...defaultPerformanceSub, ...(parsedStats.performance?.easy || {}) },
                                medium: { ...defaultPerformanceSub, ...(parsedStats.performance?.medium || {}) },
                                hard: { ...defaultPerformanceSub, ...(parsedStats.performance?.hard || {}) }
                            }
                        };
                    } catch (e) {
                        localStorage.removeItem(STATS_STORAGE_KEY);
                        gameStats = { ...defaultStatsVal };
                        logger.error("Error loading/parsing stats, resetting to default:", e);
                    }
                } else {
                    gameStats = { ...defaultStatsVal };
                }
            }
            function saveStats() {
                try { localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(gameStats)); } catch (e) { logger.error('Error saving stats:', e); }
            }
            function setInitialFocus() {
                const firstFocusableWord = wordGrid ? wordGrid.querySelector('.word-item:not(.solved):not(.disabled)') : null;
                if (firstFocusableWord) { try {firstFocusableWord.focus({preventScroll:true});} catch(e){} }
                else if (newGameBtn && newGameBtn.style.display !== 'none') { try {newGameBtn.focus();} catch(e){} }
                else if (hintBtn && !hintBtn.disabled) { try {hintBtn.focus();} catch(e){} }
            }
            const actualGridNavigationHandler = (event) => {
                const { key } = event; const activeElement = document.activeElement;
                if (!activeElement || !activeElement.classList.contains('word-item') || !wordGrid || !wordGrid.contains(activeElement) || activeElement.classList.contains('solved') || activeElement.classList.contains('disabled')) return;
                if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) return;
                event.preventDefault();
                const focusableItems = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved):not(.disabled)'));
                if (focusableItems.length === 0) return;
                let currentIndex = focusableItems.indexOf(activeElement);
                if (currentIndex === -1 && focusableItems.length > 0) { focusableItems[0].focus(); return; }
                const numCols = window.innerWidth <= 480 ? 2 : 4; let targetIndex = -1;
                switch (key) {
                    case 'ArrowUp':   targetIndex = currentIndex - numCols; break;
                    case 'ArrowDown': targetIndex = currentIndex + numCols; break;
                    case 'ArrowLeft': if (currentIndex % numCols !== 0) targetIndex = currentIndex - 1; break;
                    case 'ArrowRight': if ((currentIndex % numCols < numCols - 1) && currentIndex < focusableItems.length - 1) targetIndex = currentIndex + 1; break;
                }
                if (targetIndex >= 0 && targetIndex < focusableItems.length) { try {focusableItems[targetIndex].focus();} catch(e){} }
            };
            function setupGridNavigation() {
                if(wordGrid) {
                    wordGrid.removeEventListener('keydown', actualGridNavigationHandler);
                    wordGrid.addEventListener('keydown', actualGridNavigationHandler);
                }
            }
            function addPostGameReviewListeners() {
                if(!solvedGroupsArea) return;
                solvedGroupsArea.querySelectorAll('.solved-group').forEach(groupDiv => {
                    if (!groupDiv.classList.contains('reviewable')) { // Add only if not already added
                        groupDiv.classList.add('reviewable');
                        groupDiv.setAttribute('tabindex', '0');
                        groupDiv.addEventListener('click', handleReviewGroupClick);
                        groupDiv.addEventListener('keydown', (event) => { if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); handleReviewGroupClick(event); }});
                    }
                });
            }
            function handleReviewGroupClick(event) {
                if(!wordGrid) return;
                const groupDiv = event.currentTarget;
                const wordsToHighlight = JSON.parse(groupDiv.dataset.words || '[]');
                wordGrid.querySelectorAll('.word-item.highlight-review').forEach(el => el.classList.remove('highlight-review'));
                wordsToHighlight.forEach(word => {
                    const wordItem = wordGrid.querySelector(`.word-item.solved[data-word="${word.toUpperCase()}"]`);
                    if (wordItem) wordItem.classList.add('highlight-review');
                });
            }

            function openModal(modalElement, focusElement = null) {
                if (modalElement) {
                    elementToFocusOnModalClose = document.activeElement;
                    currentOpenModal = modalElement;
                    modalElement.style.display = 'flex';
                    setTimeout(() => {
                        modalElement.classList.add('modal-open');
                        modalFocusableElements = Array.from(modalElement.querySelectorAll('button, input, [href], select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el => el && typeof el.focus === 'function' && el.offsetParent !== null);
                        if (focusElement && modalFocusableElements.includes(focusElement)) {
                           try{ focusElement.focus(); } catch(e){}
                        } else if (modalFocusableElements.length > 0) {
                           try{ modalFocusableElements[0].focus(); } catch(e){}
                        }
                        document.addEventListener('keydown', handleModalFocusTrap);
                    }, 10);
                }
            }
            function closeModal(modalElement) {
                if (modalElement && currentOpenModal === modalElement) {
                    document.removeEventListener('keydown', handleModalFocusTrap);
                    modalElement.classList.remove('modal-open');
                    currentOpenModal = null;
                    setTimeout(() => {
                        if (modalElement && !modalElement.classList.contains('modal-open')) modalElement.style.display = 'none';
                        if (elementToFocusOnModalClose && typeof elementToFocusOnModalClose.focus === 'function') {
                           try { elementToFocusOnModalClose.focus(); } catch(e) { logger.warn("Failed to focus on previous element", e); }
                        }
                        elementToFocusOnModalClose = null;
                    }, 300);
                }
            }

            async function submitScore() {
                if (!playerNameInput || !currentPuzzle) return;
                const playerName = playerNameInput.value.trim();
                if (playerName.length < 3 || playerName.length > 10) {
                    showFeedback("Name must be 3-10 characters long.", "feedback-incorrect", 3000);
                    playerNameInput.focus(); return;
                }
                if(confirmSubmitScoreBtn) confirmSubmitScoreBtn.disabled = true;
                if(cancelSubmitScoreBtn) cancelSubmitScoreBtn.disabled = true;
                showFeedback("Submitting score...", "", 0);
                try {
                    const payload = {
                        player_name: playerName, score: score,
                        puzzle_difficulty: currentPuzzle.difficulty || 'unknown',
                        time_taken: startTime ? Math.floor((Date.now() - startTime) / 1000) : null,
                        puzzle_id: currentPuzzle?.puzzle_id || null,
                        game_mode: isChallengeGame ? "challenge" : (isDailyChallenge ? "daily" : gameMode)
                    };
                    logger.info("Submitting score with payload:", payload);
                    const response = await fetch('/api/submit_score', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });
                    let responseDataText = await response.text();
                    logger.info("Score submission response status:", response.status);
                    logger.debug("Score submission response text:", responseDataText);
                    if (!response.ok) {
                        let serverErrorMessage = `Score submission failed: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = JSON.parse(responseDataText);
                            if (errorData && errorData.detail) {
                                if (typeof errorData.detail === 'string') serverErrorMessage = errorData.detail;
                                else if (Array.isArray(errorData.detail) && errorData.detail.length > 0 && errorData.detail[0].msg) serverErrorMessage = errorData.detail.map(err => `${err.loc.join('.')} - ${err.msg}`).join('; ');
                                else serverErrorMessage = JSON.stringify(errorData);
                            } else if (errorData && errorData.message) serverErrorMessage = errorData.message;
                        } catch (e) { /* Use default if not JSON */ }
                        throw new Error(serverErrorMessage);
                    }
                    const result = JSON.parse(responseDataText);
                    showFeedback(result.message || "Score submitted successfully!", "feedback-correct", 3000);
                    closeModal(scoreSubmitModal);
                } catch (error) {
                    logger.error('Error submitting score:', error);
                    showFeedback(`Score Submission Failed: ${error.message}`, 'feedback-incorrect', 4000);
                } finally {
                    if(confirmSubmitScoreBtn) confirmSubmitScoreBtn.disabled = false;
                    if(cancelSubmitScoreBtn) cancelSubmitScoreBtn.disabled = false;
                }
            }

            function openLeaderboardModal() {
                fetchLeaderboardData(lbDifficultyFilter.value || null, lbModeFilter.value);
                openModal(leaderboardModal, lbDifficultyFilter);
            }
            async function fetchLeaderboardData(difficulty = null, mode = 'classic') {
                if (!leaderboardModalBody || !lbNoScoresMessage) return;
                leaderboardModalBody.innerHTML = '<tr><td colspan="5" style="text-align:center;">Loading...</td></tr>';
                lbNoScoresMessage.style.display = 'none';
                let url = `/api/leaderboard?mode=${encodeURIComponent(mode)}&limit=20`;
                if (difficulty && difficulty !== "") { url += `&difficulty=${encodeURIComponent(difficulty)}`; }
                try {
                    const response = await fetch(url);
                    if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                    const data = await response.json();
                    displayLeaderboardInModal(data.leaderboard);
                } catch (error) {
                    logger.error("Error fetching leaderboard:", error);
                    leaderboardModalBody.innerHTML = '<tr><td colspan="5" style="text-align:center; color:red;">Error loading leaderboard.</td></tr>';
                }
            }
            function displayLeaderboardInModal(scores) {
                if (!leaderboardModalBody || !lbNoScoresMessage) return;
                leaderboardModalBody.innerHTML = '';
                if (!scores || scores.length === 0) { lbNoScoresMessage.style.display = 'block'; return; }
                lbNoScoresMessage.style.display = 'none';
                scores.forEach((score, index) => {
                    const row = leaderboardModalBody.insertRow();
                    row.insertCell().textContent = index + 1;
                    row.insertCell().textContent = score.player_name;
                    row.insertCell().textContent = score.score;
                    row.insertCell().textContent = score.time_taken_seconds !== null && score.time_taken_seconds !== undefined ? score.time_taken_seconds : 'N/A';
                    let submittedDate = 'N/A';
                    if (score.timestamp) {
                        try { submittedDate = new Date(score.timestamp).toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });}
                        catch (e) { logger.warn("Could not parse timestamp: ", score.timestamp); }
                    }
                    row.insertCell().textContent = submittedDate;
                });
            }

            function getShareMessage() {
                let message = `I just scored ${score} in WordLinks!`;
                if (currentPuzzle && currentPuzzle.difficulty && currentPuzzle.difficulty.toLowerCase() !== 'unknown') {
                    message += ` (Difficulty: ${currentPuzzle.difficulty})`;
                }
                if (gameMode === "classic" && startTime && !isDailyChallenge && !isChallengeGame) {
                    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                    const minutes = Math.floor(elapsedSeconds / 60);
                    const seconds = elapsedSeconds % 60;
                    message += ` Time: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.`;
                }
                message += " Can you beat my score?";
                return message;
            }
            function shareToTwitter() {
                if (!gameActive && score > 0 && !isDailyChallenge && !isChallengeGame) {
                    const text = getShareMessage();
                    const gameUrl = window.location.origin + "/home.html";
                    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(gameUrl)}&hashtags=WordLinksGame,PuzzleGame`;
                    window.open(twitterUrl, '_blank', 'noopener,noreferrer');
                } else { showFeedback("Sharing available for completed, non-daily/challenge games with a score!", "feedback-incorrect", 3000); }
            }
            function shareToLinkedIn() {
                if (!gameActive && score > 0 && !isDailyChallenge && !isChallengeGame) {
                    const gameUrl = window.location.origin + "/home.html";
                    const title = "I crushed it on WordLinks!";
                    const summary = getShareMessage() + ` Play here: ${gameUrl}`;
                    const linkedInUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(gameUrl)}&title=${encodeURIComponent(title)}&summary=${encodeURIComponent(summary)}`;
                    window.open(linkedInUrl, '_blank', 'noopener,noreferrer');
                } else { showFeedback("Sharing available for completed, non-daily/challenge games with a score!", "feedback-incorrect", 3000); }
            }
            function shareToWhatsApp() {
                if (!gameActive && score > 0 && !isDailyChallenge && !isChallengeGame) {
                    const text = getShareMessage() + ` Play WordLinks: ${window.location.origin}/home.html`;
                    const whatsappUrl = `whatsapp://send?text=${encodeURIComponent(text)}`;
                    window.open(whatsappUrl, '_blank', 'noopener,noreferrer');
                } else { showFeedback("Sharing available for completed, non-daily/challenge games with a score!", "feedback-incorrect", 3000); }
            }
            function showInstagramShareInfo() {
                 if (!gameActive && score > 0 && !isDailyChallenge && !isChallengeGame) {
                    showFeedback("To share on Instagram: Take a screenshot of your score and post it!", "feedback-hint", 7000);
                } else { showFeedback("Sharing available for completed, non-daily/challenge games with a score!", "feedback-incorrect", 3000); }
            }
            async function copyGameSummaryToClipboard() {
                if (!gameActive && score > 0 && !isDailyChallenge && !isChallengeGame) {
                    const textToCopy = `${getShareMessage()} Play WordLinks here: ${window.location.origin}/home.html`;
                    try {
                        await navigator.clipboard.writeText(textToCopy);
                        showFeedback("Game summary copied to clipboard!", "", 2000);
                    } catch (err) {
                        logger.error('Failed to copy game summary: ', err);
                        showFeedback("Could not copy summary. Please copy manually.", "feedback-incorrect", 3000);
                        prompt("Copy this summary:", textToCopy);
                    }
                } else { showFeedback("Sharing available for completed, non-daily/challenge games with a score!", "feedback-incorrect", 3000); }
            }

            function handleModalFocusTrap(event) {
                if (!currentOpenModal || !currentOpenModal.classList.contains('modal-open')) return;
                if (event.key === 'Tab') {
                    if (!modalFocusableElements || modalFocusableElements.length === 0) { event.preventDefault(); return; }
                    const firstElement = modalFocusableElements[0];
                    const lastElement = modalFocusableElements[modalFocusableElements.length - 1];
                    if (event.shiftKey) {
                        if (document.activeElement === firstElement) { lastElement.focus(); event.preventDefault(); }
                    } else {
                        if (document.activeElement === lastElement) { firstElement.focus(); event.preventDefault(); }
                    }
                } else if (event.key === 'Escape') {
                    if (currentOpenModal) { closeModal(currentOpenModal); }
                }
            }

            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark-theme');
                    if (themeToggleBtn) themeToggleBtn.innerHTML = `<i class="fas ${sunIconClass}"></i>`;
                } else {
                    document.documentElement.classList.remove('dark-theme');
                    if (themeToggleBtn) themeToggleBtn.innerHTML = `<i class="fas ${moonIconClass}"></i>`;
                }
                localStorage.setItem(THEME_STORAGE_KEY, theme);
            }

            // --- Event Listeners Setup ---
            if(clearSelectionBtn) clearSelectionBtn.addEventListener('click', clearSelection);
            if(hintBtn) hintBtn.addEventListener('click', handleHintClick);
            if(shuffleBtn) shuffleBtn.addEventListener('click', shuffleWordGrid);
            if(confirmShowAnswerBtn) confirmShowAnswerBtn.addEventListener('click', async () => { closeModal(showAnswerModal); await revealAllGroups(); });
            if(cancelShowAnswerBtn) cancelShowAnswerBtn.addEventListener('click', () => closeModal(showAnswerModal));
            if(confirmSubmitScoreBtn) confirmSubmitScoreBtn.addEventListener('click', submitScore);
            if(cancelSubmitScoreBtn) cancelSubmitScoreBtn.addEventListener('click', () => closeModal(scoreSubmitModal));
            if (challengeFriendBtn) challengeFriendBtn.addEventListener('click', showChallengeLink);
            if (viewLeaderboardBtn) viewLeaderboardBtn.addEventListener('click', openLeaderboardModal);
            if (closeLeaderboardBtn) closeLeaderboardBtn.addEventListener('click', () => closeModal(leaderboardModal));
            if (lbFilterBtn) {
                lbFilterBtn.addEventListener('click', () => {
                    fetchLeaderboardData(lbDifficultyFilter.value || null, lbModeFilter.value);
                });
            }
            if (shareTwitterBtn) shareTwitterBtn.addEventListener('click', shareToTwitter);
            if (shareLinkedinBtn) shareLinkedinBtn.addEventListener('click', shareToLinkedIn);
            if (shareWhatsappBtn) shareWhatsappBtn.addEventListener('click', shareToWhatsApp);
            if (shareInstagramInfoBtn) shareInstagramInfoBtn.addEventListener('click', showInstagramShareInfo);
            if (copySummaryBtn) copySummaryBtn.addEventListener('click', copyGameSummaryToClipboard);
            if (newGameBtn) newGameBtn.onclick = goToHome;
            if (viewSolutionBtn) {
                viewSolutionBtn.onclick = async () => {
                    if(viewSolutionBtn) viewSolutionBtn.disabled = true;
                    if(viewSolutionBtn) viewSolutionBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Revealing...';
                    await revealAllGroups();
                 };
            }
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', () => {
                    if (document.documentElement.classList.contains('dark-theme')) applyTheme('light');
                    else applyTheme('dark');
                });
            }

            // --- Initializations ---
            const savedTheme = localStorage.getItem(THEME_STORAGE_KEY);
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme) applyTheme(savedTheme); else if (prefersDark) applyTheme('dark'); else applyTheme('light');

            initGame();
        });
        } catch (e) {
            console.error("GLOBAL CATCH: Critical error on page load or during script execution:", e);
            const body = document.querySelector('body');
            if (body) {
                body.innerHTML = `<div style="padding:20px; text-align:center; font-family:sans-serif;"><h1>Oops!</h1><p>A critical error occurred: ${e.message}</p><p>Please try refreshing the page or contact support.</p></div>`;
            }
        }
    </script>
</body>
</html>