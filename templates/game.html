<!DOCTYPE html>
<html lang="en"> <!-- Theme class added by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordLinks - Play</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <style>
        /* --- Base & Typography --- */
        :root { /* Light Theme (Default) */
            --bg-gradient-start: #f8f9fa; --bg-gradient-end: #ffffff;
            --container-bg: #ffffff; --text-primary: #343a40; --text-secondary: #6c757d;
            --accent-primary: #007bff; --accent-secondary: #8f94fb;
            --selected-bg: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%); --selected-text: #ffffff;
            --solved-bg: #e9ecef; --solved-text: #adb5bd; --disabled-opacity: 0.6;
            --correct-bg: #d1e7dd; --correct-text: #0f5132; --correct-border: #badbcc;
            --incorrect-bg: #f8d7da; --incorrect-text: #842029; --incorrect-border: #f5c2c7;
            --hint-bg: #cff4fc; --hint-text: #055160; --hint-border: #b6effb;
            --button-primary-bg: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            --button-primary-hover: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            --button-warning-bg: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            --button-warning-hover: linear-gradient(135deg, #e0a800 0%, #c69500 100%);
            --button-info-bg: linear-gradient(135deg, #17a2b8 0%, #117a8b 100%);
            --button-info-hover: linear-gradient(135deg, #117a8b 0%, #0f6674 100%);
            --button-shuffle-bg: linear-gradient(135deg, #fd7e14 0%, #e85a00 100%); /* Orange for Shuffle */
            --button-shuffle-hover: linear-gradient(135deg, #e85a00 0%, #c54a00 100%);
            --button-success-bg: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            --button-success-hover: linear-gradient(135deg, #1e7e34 0%, #155724 100%);
            --button-disabled-bg: #ced4da; --button-disabled-text: #6c757d;
            --container-border: rgba(255, 255, 255, 0.3); --blur-intensity: 10px;
            --solved-color-0-bg: linear-gradient(135deg, #fefae0 0%, #faedcd 100%);
            --solved-color-0-text: #bc6c25; --solved-color-0-border: #e9c46a;
            --solved-color-1-bg: linear-gradient(135deg, #caf0f8 0%, #ade8f4 100%);
            --solved-color-1-text: #0077b6; --solved-color-1-border: #48cae4;
            --solved-color-2-bg: linear-gradient(135deg, #d8f3dc 0%, #b7e4c7 100%);
            --solved-color-2-text: #2d6a4f; --solved-color-2-border: #74c69d;
            --solved-color-3-bg: linear-gradient(135deg, #fec8d8 0%, #ffacb7 100%);
            --solved-color-3-text: #c9184a; --solved-color-3-border: #ff758f;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1); --shadow-md: 0 4px 8px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.1); --transition-speed: 0.25s;
            --word-item-base-bg: #f8f9fa; --word-item-base-border: #dee2e6;
            --controls-bg: #f8f9fa; --status-bar-bg: #f8f9fa;
            --modal-overlay-bg: rgba(0, 0, 0, 0.6);
            --theme-toggle-btn-color: var(--text-secondary);
            --theme-toggle-btn-hover-color: var(--text-primary);
            --error-message-bg: var(--incorrect-bg); --error-message-text: var(--incorrect-text);
            --error-message-border: var(--incorrect-border);
            --timer-default-color: var(--accent-primary);
            --timer-warning-color: var(--incorrect-text);
            --daily-indicator-bg: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            --daily-indicator-text: var(--accent-primary);
        }

        html.dark-theme { /* Dark Theme Overrides */
            --bg-gradient-start: #212529; --bg-gradient-end: #343a40;
            --container-bg: #495057; --text-primary: #f8f9fa; --text-secondary: #adb5bd;
            --accent-primary: #0d6efd;
            --selected-bg: linear-gradient(135deg, #5e31a7 0%, #1a5bbd 100%);
            --solved-bg: #343a40; --solved-text: #6c757d;
            --correct-bg: #14452F; --correct-text: #a3d4b8; --correct-border: #2f6f4f;
            --incorrect-bg: #591C21; --incorrect-text: #f5c2c7; --incorrect-border: #8c222c;
            --hint-bg: #033C4A; --hint-text: #b6effb; --hint-border: #0f6674;
            --button-disabled-bg: #5a6268; --button-disabled-text: #adb5bd;
            --button-shuffle-bg: linear-gradient(135deg, #c4630e 0%, #b04e00 100%);
            --button-shuffle-hover: linear-gradient(135deg, #b04e00 0%, #934000 100%);
            --solved-color-0-bg: linear-gradient(135deg, #4d441e 0%, #443b19 100%);
            --solved-color-0-text: #fefae0; --solved-color-0-border: #8a6d3b;
            --solved-color-1-bg: linear-gradient(135deg, #004c75 0%, #003d5e 100%);
            --solved-color-1-text: #caf0f8; --solved-color-1-border: #006298;
            --solved-color-2-bg: linear-gradient(135deg, #1c4b33 0%, #153826 100%);
            --solved-color-2-text: #d8f3dc; --solved-color-2-border: #255a40;
            --solved-color-3-bg: linear-gradient(135deg, #8a1234 0%, #700f2b 100%);
            --solved-color-3-text: #fec8d8; --solved-color-3-border: #b01742;
            --word-item-base-bg: #3E444A; --word-item-base-border: #5A6268;
            --controls-bg: #343a40; --status-bar-bg: #343a40;
            --modal-overlay-bg: rgba(0, 0, 0, 0.8);
            --theme-toggle-btn-color: var(--text-secondary);
            --theme-toggle-btn-hover-color: var(--text-primary);
            --error-message-bg: var(--incorrect-bg); --error-message-text: var(--incorrect-text);
            --error-message-border: var(--incorrect-border);
            --timer-default-color: var(--accent-primary);
            --timer-warning-color: var(--incorrect-text);
            --daily-indicator-bg: color-mix(in srgb, var(--accent-primary) 25%, transparent);
            --daily-indicator-text: var(--accent-primary);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Poppins', sans-serif; line-height: 1.6;
            background: linear-gradient(to bottom, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-primary); padding: 20px; min-height: 100vh;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; animation: fadeInPage 0.5s ease-out forwards;
            transition: background var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        @keyframes fadeInPage { to { opacity: 1; } }
        body.fade-out { opacity: 1; animation: fadeOutPage 0.3s ease-in forwards; }
        @keyframes fadeOutPage { to { opacity: 0; } }
        .container {
            width: 100%; max-width: 700px; margin: 20px auto;
            background: var(--container-bg); padding: 30px;
            border-radius: 16px; box-shadow: var(--shadow-lg);
            position: relative;
            transition: background-color var(--transition-speed) ease;
        }
        #theme-toggle-btn {
            position: absolute; top: 15px; right: 15px;
            background: none; border: none; font-size: 1.3em; cursor: pointer;
            color: var(--theme-toggle-btn-color); padding: 5px;
            transition: color var(--transition-speed) ease, transform var(--transition-speed) ease;
        }
        #theme-toggle-btn:hover { color: var(--theme-toggle-btn-hover-color); transform: scale(1.1); }
        h1 { text-align: center; color: var(--text-primary); margin-bottom: 5px; font-weight: 700; transition: color var(--transition-speed) ease;}
        .daily-challenge-indicator {
            text-align: center; font-weight: bold; color: var(--daily-indicator-text);
            background-color: var(--daily-indicator-bg);
            padding: 5px 0; margin-bottom: 10px; border-radius: 6px;
            font-size: 0.9em;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        h2 { text-align: center; color: var(--text-secondary); margin-bottom: 15px; font-weight: 600; transition: color var(--transition-speed) ease;}
        .status-bar {
            display: flex; justify-content: space-around; align-items: center;
            padding: 15px 0; margin-bottom: 20px; border-bottom: 1px solid var(--word-item-base-border);
            flex-wrap: wrap; gap: 15px; background-color: var(--status-bar-bg);
            border-radius: 8px; box-shadow: var(--shadow-sm);
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .status-bar div {
            font-weight: 600; font-size: 0.9em; text-align: center;
            flex-basis: auto; flex-grow: 1; color: var(--text-secondary);
            transition: color var(--transition-speed) ease;
        }
        .status-bar span {
            font-weight: 700; color: var(--accent-primary);
            font-size: 1.1em; margin-left: 5px;
            transition: color var(--transition-speed) ease;
        }
        #timer { min-width: 80px; color: var(--timer-default-color); transition: color 0.3s ease; }
        #timer.countdown-active { font-weight: bold; }
        #timer.countdown-warning { color: var(--timer-warning-color) !important; animation: pulseWarning 1s infinite alternate; }
        @keyframes pulseWarning { from { transform: scale(1); } to { transform: scale(1.05); } }

        #word-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 25px; }
        .word-item {
            background-color: var(--word-item-base-bg); padding: 15px 8px; text-align: center;
            border-radius: 8px; cursor: pointer; font-weight: 600; text-transform: uppercase;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease,
                        transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            user-select: none; min-height: 3.5em; display: flex;
            align-items: center; justify-content: center; line-height: 1.2;
            word-break: break-word; box-shadow: var(--shadow-sm); border: 1px solid var(--word-item-base-border);
            color: var(--text-primary);
        }
        .word-item:hover:not(.selected):not(.solved):not(.disabled) {
             background-color: var(--accent-secondary); color: var(--selected-text);
             transform: translateY(-3px); box-shadow: var(--shadow-md);
        }
        html.dark-theme .word-item:hover:not(.selected):not(.solved):not(.disabled) { background-color: #5f67ee; }
        .word-item:focus-visible, .solved-group.reviewable:focus-visible {
            outline: 3px solid var(--accent-primary); outline-offset: 2px; box-shadow: var(--shadow-md);
        }
        .word-item.selected {
            background: var(--selected-bg); color: var(--selected-text);
            transform: scale(1.05) translateY(-2px); box-shadow: var(--shadow-md); border: none;
        }
        .word-item.solved,
        .word-item.disabled {
            background-color: var(--solved-bg); color: var(--solved-text);
            cursor: default; opacity: var(--disabled-opacity); box-shadow: none;
            border: 1px solid var(--solved-text); transform: none;
        }
        .word-item.correct-match-animation { animation: correctMatchPop 0.6s ease-out forwards; }
        @keyframes correctMatchPop {
            0% { transform: scale(1.05) translateY(-2px); opacity: 1; }
            50% { transform: scale(1.2) translateY(-5px) rotate(3deg); opacity: 0.9; background-color: var(--correct-bg); color: var(--correct-text); }
            100% { transform: scale(1); opacity: 1; }
        }
        .controls {
            text-align: center; margin-bottom: 20px; display: grid; /* Changed to grid */
            grid-template-columns: 1fr auto auto auto; /* Text takes space, buttons fit content */
            align-items: center;
            gap: 10px; padding: 15px; background-color: var(--controls-bg);
            border-radius: 8px; box-shadow: var(--shadow-sm);
            transition: background-color var(--transition-speed) ease;
        }
        .controls p {
            margin: 0; white-space: nowrap; font-size: 0.9em;
            color: var(--text-secondary); text-align: left; /* Align text left in its cell */
            transition: color var(--transition-speed) ease;
            grid-column: 1 / 2; /* Make text span first "flexible" column */
        }
        .controls p span { font-weight: 700; color: var(--accent-primary); font-size: 1.1em; transition: color var(--transition-speed) ease;}
        .controls button, .post-game-actions button {
            padding: 10px 18px; /* Slightly less padding for more buttons */
            cursor: pointer; border-radius: 25px;
            border: none; font-weight: 600; font-size: 0.85em; /* Slightly smaller font */
            color: white;
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm);
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        }
        .controls button:hover:not(:disabled), .post-game-actions button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: var(--shadow-md); }
        .controls button:active:not(:disabled), .post-game-actions button:active:not(:disabled) { transform: translateY(0); box-shadow: var(--shadow-sm); }

        #clear-selection-btn { background: var(--button-warning-bg); }
        #clear-selection-btn:hover:not(:disabled) { background: var(--button-warning-hover); }
        #hint-btn { background: var(--button-info-bg); }
        #hint-btn:hover:not(:disabled) { background: var(--button-info-hover); }
        #shuffle-btn { background: var(--button-shuffle-bg); } /* ** NEW ** */
        #shuffle-btn:hover:not(:disabled) { background: var(--button-shuffle-hover); } /* ** NEW ** */

        .controls button:disabled, .post-game-actions button:disabled {
            background: var(--button-disabled-bg); color: var(--button-disabled-text);
            cursor: not-allowed; box-shadow: none; transform: none;
        }
        #feedback-area {
            margin-top: 15px; margin-bottom: 20px; padding: 15px 20px;
            border-radius: 8px; min-height: 3em; text-align: center; font-weight: 600;
            box-sizing: border-box; display: flex; align-items: center; justify-content: center;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            border: 1px solid transparent;
        }
        .feedback-correct { background-color: var(--correct-bg); color: var(--correct-text); border-color: var(--correct-border); }
        .feedback-incorrect { background-color: var(--incorrect-bg); color: var(--incorrect-text); border-color: var(--incorrect-border); }
        .feedback-hint { background-color: var(--hint-bg); color: var(--hint-text); border-color: var(--hint-border); }
        #solved-groups-area { margin-bottom: 25px; display: grid; grid-template-columns: 1fr; gap: 15px; }
        .solved-group {
            border-radius: 12px; padding: 15px 20px; text-align: center;
            box-shadow: var(--shadow-md); border-width: 2px; border-style: solid;
            transition: transform 0.3s ease-out, opacity 0.5s ease-out, background var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            transform: scale(0.95); opacity: 0; animation: fadeInScale 0.5s ease-out forwards;
        }
        @keyframes fadeInScale { to { opacity: 1; transform: scale(1); } }
        .solved-group.reviewable { cursor: pointer; }
        .solved-group.reviewable:hover { box-shadow: var(--shadow-lg); transform: scale(1.02); }
        .solved-group strong { display: block; margin-bottom: 8px; text-transform: uppercase; font-size: 1em; font-weight: 700; }
        .solved-group p { margin: 0; font-size: 0.95em; font-weight: 400; line-height: 1.5; }
        .solved-group-color-0 { background: var(--solved-color-0-bg); color: var(--solved-color-0-text); border-color: var(--solved-color-0-border); animation-delay: 0s; }
        .solved-group-color-1 { background: var(--solved-color-1-bg); color: var(--solved-color-1-text); border-color: var(--solved-color-1-border); animation-delay: 0.1s; }
        .solved-group-color-2 { background: var(--solved-color-2-bg); color: var(--solved-color-2-text); border-color: var(--solved-color-2-border); animation-delay: 0.2s; }
        .solved-group-color-3 { background: var(--solved-color-3-bg); color: var(--solved-color-3-text); border-color: var(--solved-color-3-border); animation-delay: 0.3s; }
        .word-item.highlight-review {
            background-color: var(--hint-bg) !important; color: var(--hint-text) !important;
            border: 2px solid var(--hint-border) !important; opacity: 1 !important; transform: scale(1.03);
            transition: background-color 0.1s ease-out, color 0.1s ease-out, border-color 0.1s ease-out, transform 0.1s ease-out;
        }
        .word-item.highlight-hint {
            outline: 3px dashed var(--accent-secondary); outline-offset: 2px;
            transition: outline 0.2s ease-out; position: relative; z-index: 5;
        }
        .post-game-actions { margin-top: 25px; }
        #new-game-btn { background: var(--button-success-bg); }
        #new-game-btn:hover:not(:disabled) { background: var(--button-success-hover); }
        #view-solution-btn { background: var(--button-info-bg); }
        #view-solution-btn:hover:not(:disabled) { background: var(--button-info-hover); }
        .error-message {
             text-align: center; color: var(--error-message-text); font-style: normal;
             background-color: var(--error-message-bg); border: 1px solid var(--error-message-border);
             padding: 10px 15px; border-radius: 8px; font-weight: 600; margin-top: 15px; margin-bottom: 20px;
             transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        #loading-message, #puzzle-info {
             text-align: center; color: var(--text-secondary);
             font-style: italic; margin-bottom: 15px;
             transition: color var(--transition-speed) ease;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0) scale(1.05) translateY(-2px); }
            20% { transform: translateX(-7px) scale(1.05) translateY(-2px) rotate(-2deg); }
            40% { transform: translateX(7px) scale(1.05) translateY(-2px) rotate(2deg); }
            60% { transform: translateX(-5px) scale(1.05) translateY(-2px) rotate(-1deg); }
            80% { transform: translateX(5px) scale(1.05) translateY(-2px) rotate(1deg); }
        }
        .modal-overlay {
            position: fixed; inset: 0; background-color: var(--modal-overlay-bg);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s, background-color var(--transition-speed) ease;
        }
        .modal-overlay.modal-open { opacity: 1; visibility: visible; }
        .modal-content {
            background: var(--container-bg); padding: 30px 40px; border-radius: 15px;
            border: 1px solid var(--container-border); box-shadow: var(--shadow-lg);
            backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity));
            max-width: 450px; width: 90%; text-align: center; color: var(--text-primary);
            transform: scale(0.9);
            transition: transform 0.3s ease, background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .modal-overlay.modal-open .modal-content { transform: scale(1); }
        .modal-title {
            font-size: 1.5em; font-weight: 700; margin-bottom: 15px;
            display: flex; align-items: center; justify-content: center;
            gap: 10px; color: var(--accent-primary);
            transition: color var(--transition-speed) ease;
        }
        .modal-content p { margin-bottom: 25px; font-size: 1em; line-height: 1.6; color: var(--text-secondary); transition: color var(--transition-speed) ease;}
        .modal-actions { display: flex; justify-content: space-around; gap: 15px; flex-wrap: wrap; }
        .modal-button {
            padding: 10px 25px; cursor: pointer; border-radius: 25px;
            border: 1px solid transparent; font-weight: 600; font-size: 0.9em; color: #fff;
            transition: background var(--transition-speed) ease, transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            box-shadow: var(--shadow-sm); display: flex; align-items: center; gap: 8px;
        }
        .modal-button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: var(--shadow-md); }
        .modal-button:focus-visible { outline: 3px solid var(--accent-primary); outline-offset: 1px; }
        .modal-button-confirm { background: var(--button-success-bg); }
        .modal-button-confirm:hover:not(:disabled) { background: var(--button-success-hover); }
        .modal-button-cancel { background: var(--button-warning-bg); color: var(--text-primary); }
        html.dark-theme .modal-button-cancel { color: var(--text-primary); }
        .modal-button-cancel:hover:not(:disabled) { background: var(--button-warning-hover); }
        .modal-button i { font-size: 1.1em; }

        @media (max-width: 480px) {
            .modal-content { padding: 20px 25px; } .modal-title { font-size: 1.3em; }
            .modal-actions { flex-direction: column; align-items: center; }
            .modal-button { width: 80%; justify-content: center; }
        }
        @media (max-width: 768px) {
            .container { padding: 20px; } #theme-toggle-btn { top: 10px; right: 10px; }
            h1 { font-size: 1.8em; }
            .status-bar { padding: 10px; } .status-bar div { font-size: 0.85em; } .status-bar span { font-size: 1em; }
            #word-grid { gap: 10px; } .word-item { font-size: 0.9em; min-height: 3.2em; padding: 12px 5px; }
            .controls { grid-template-columns: 1fr; justify-items: center; } /* Stack controls on smaller screens */
            .controls p { text-align: center; margin-bottom: 10px; grid-column: 1 / -1; /* Span full width */ }
            .controls button { width: 60%; } /* Adjust button width as needed */
            .post-game-actions button { width: 70%;}
        }
        @media (max-width: 480px) {
            body { padding: 10px; } .container { padding: 15px; border-radius: 12px; }
            h1 { font-size: 1.5em; margin-bottom: 10px;} h2 { font-size: 1em; margin-bottom: 15px; }
            .status-bar { flex-direction: column; align-items: stretch; gap: 8px; padding: 8px; }
            .status-bar div { text-align: left; padding: 0 10px; }
            #word-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 20px;}
            .word-item { font-size: 0.85em; min-height: 3.5em; font-weight: 600; }
            .controls button { width: 85%; }
            .post-game-actions button { width: 85%;}
            #feedback-area { padding: 10px 15px; font-size: 0.9em;}
            .solved-group { padding: 10px 15px; } .solved-group strong { font-size: 0.9em; } .solved-group p { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <!-- Sound effect elements -->
    <audio id="select-sound" src="/static/sounds/select.mp3" preload="auto"></audio>
    <audio id="correct-sound" src="/static/sounds/correct.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="/static/sounds/incorrect.mp3" preload="auto"></audio>
    <audio id="win-sound" src="/static/sounds/win.mp3" preload="auto"></audio>
    <audio id="lose-sound" src="/static/sounds/lose.mp3" preload="auto"></audio>
    <!-- ** NEW: Shuffle Sound (optional) ** -->
    <audio id="shuffle-sound" src="/static/sounds/shuffle.mp3" preload="auto"></audio>


    <div class="container game-container">
        <button id="theme-toggle-btn" aria-label="Toggle dark mode">
            <i class="fas fa-moon"></i>
        </button>

        <h1>WordLinks</h1>
        <div id="daily-challenge-indicator" class="daily-challenge-indicator" style="display: none;">
            🌟 Daily Challenge 🌟
        </div>
        <div class="status-bar">
            <div id="timer-container">
                <span id="timer-label">Time: </span><span id="timer">00:00</span>
            </div>
            <div>Score: <span id="score">1000</span></div>
            <div>Hints: <span id="hints-used">0</span> / <span id="hints-allowed">3</span></div>
            <div>Mistakes: <span id="lives-remaining">4</span></div>
        </div>

        <p id="loading-message">Loading puzzle...</p>
        <p id="error-message" class="error-message" style="display: none;"></p>
        <div id="puzzle-info"></div>

        <div id="solved-groups-area"></div>
        <div id="word-grid" role="grid"></div>

        <!-- ****** MODIFIED: Controls Area for Shuffle Button ****** -->
        <div class="controls">
             <p>Selected: <span id="selected-count">0</span> / 4</p>
             <button id="shuffle-btn"><i class="fas fa-random"></i> Shuffle</button> <!-- ** NEW ** -->
             <button id="clear-selection-btn" disabled><i class="fas fa-times-circle"></i> Clear</button>
             <button id="hint-btn"><i class="fas fa-lightbulb"></i> Hint</button>
        </div>
        <!-- ****** END: Controls Area ****** -->


        <div id="feedback-area" aria-live="polite" aria-atomic="true"></div>

        <div class="post-game-actions" style="display: none;">
            <button id="view-solution-btn">
                <i class="fas fa-eye"></i> View Solution
            </button>
            <button id="new-game-btn">
                <i class="fas fa-redo"></i> Play Again?
            </button>
        </div>

        <div id="show-answer-modal" class="modal-overlay" style="display: none;" role="dialog" aria-labelledby="show-answer-modal-title" aria-modal="true">
            <div class="modal-content">
                <h3 id="show-answer-modal-title" class="modal-title"><i class="fas fa-eye"></i> Hints Exhausted</h3>
                <p>You've used all available hints. Would you like to reveal the solution?</p>
                <div class="modal-actions">
                    <button id="confirm-show-answer-btn" class="modal-button modal-button-confirm">
                        <i class="fas fa-check"></i> Show Answer
                    </button>
                    <button id="cancel-show-answer-btn" class="modal-button modal-button-cancel">
                        <i class="fas fa-times"></i> Keep Playing
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const wordGrid = document.getElementById('word-grid');
            const loadingMessage = document.getElementById('loading-message');
            const errorMessage = document.getElementById('error-message');
            const selectedCountSpan = document.getElementById('selected-count');
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            const feedbackArea = document.getElementById('feedback-area');
            const solvedGroupsArea = document.getElementById('solved-groups-area');
            const livesRemainingSpan = document.getElementById('lives-remaining');
            const puzzleInfoDiv = document.getElementById('puzzle-info');
            const timerSpan = document.getElementById('timer');
            const timerLabelSpan = document.getElementById('timer-label');
            const scoreSpan = document.getElementById('score');
            const hintBtn = document.getElementById('hint-btn');
            const shuffleBtn = document.getElementById('shuffle-btn'); // ** NEW **
            const hintsUsedSpan = document.getElementById('hints-used');
            const hintsAllowedSpan = document.getElementById('hints-allowed');
            const showAnswerModal = document.getElementById('show-answer-modal');
            const confirmShowAnswerBtn = document.getElementById('confirm-show-answer-btn');
            const cancelShowAnswerBtn = document.getElementById('cancel-show-answer-btn');
            const postGameActionsDiv = document.querySelector('.post-game-actions');
            const viewSolutionBtn = document.getElementById('view-solution-btn');
            const newGameBtn = document.getElementById('new-game-btn');
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const dailyChallengeIndicator = document.getElementById('daily-challenge-indicator');


            const selectSound = document.getElementById('select-sound');
            const correctSound = document.getElementById('correct-sound');
            const incorrectSound = document.getElementById('incorrect-sound');
            const winSound = document.getElementById('win-sound');
            const loseSound = document.getElementById('lose-sound');
            const shuffleSound = document.getElementById('shuffle-sound'); // ** NEW **

            // --- Game Configuration ---
            const STARTING_LIVES = 4;
            const STARTING_SCORE = 1000;
            const INCORRECT_GUESS_PENALTY = 75;
            const HINT_PENALTY = 150;
            const MAX_HINTS = 3;
            const PUZZLE_STORAGE_KEY = 'currentPuzzle';
            const STATS_STORAGE_KEY = 'wordLinksGameStats';
            const THEME_STORAGE_KEY = 'wordLinksTheme';
            const SHUFFLE_PENALTY_SCORE = 25; // ** NEW: Optional score penalty for shuffle **
            const MAX_SHUFFLES_ALLOWED = 3; // ** NEW: Optional limit on shuffles **


            const POINTS_PER_CORRECT_GROUP = 200;
            const TIME_BONUS_TARGET_SECONDS = 180;
            const TIME_BONUS_PER_SECOND_SAVED = 2;
            const GROUP_STREAK_THRESHOLD = 2;
            const GROUP_STREAK_BONUS_MULTIPLIER = 50;
            const PUZZLE_STREAK_BONUS_PER_STREAK = 100;
            const COUNTDOWN_WIN_BONUS_PER_SECOND = 1;


            // --- Game State Variables ---
            let currentPuzzle = null, selectedWords = [], lives = STARTING_LIVES, score = STARTING_SCORE;
            let hintsUsed = 0, revealedGroupsCount = 0, solvedGroupKeys = [], isSubmitting = false;
            let gameActive = false, timerInterval = null, startTime = null, feedbackTimeout = null;
            let gameStats = { wins: 0, losses: 0, currentStreak: 0, maxStreak: 0, fastestTime: null, perfectWins: 0 };
            let hintHighlightTimeout = null, elementToFocusOnModalClose = null;
            let modalFocusableElements = [], currentOpenModal = null;
            const sunIconClass = 'fa-sun', moonIconClass = 'fa-moon';
            let currentGroupStreak = 0;
            let gameMode = "classic";
            let countdownDuration = 0;
            let timeLeft = 0;
            let isDailyChallenge = false;
            let shufflesUsed = 0; // ** NEW: Track shuffles **


            function playSound(soundElement) {
                if (soundElement && typeof soundElement.play === 'function') {
                    if (soundElement.readyState >= 2 || !soundElement.error) {
                        soundElement.currentTime = 0;
                        soundElement.play().catch(error => console.warn("Audio play failed:", soundElement.id, error));
                    } else if (soundElement.error) {
                         console.warn("Cannot play sound, media error:", soundElement.id, soundElement.error);
                    } else {
                         console.warn("Cannot play sound, not enough data or error:", soundElement.id, "ReadyState:", soundElement.readyState);
                    }
                } else if (soundElement) {
                    console.warn("Attempted to play sound on a non-playable audio element:", soundElement.id);
                }
            }

            function initGame() {
                closeShowAnswerModal(); stopTimer(); gameActive = false;
                loadStats();

                isDailyChallenge = sessionStorage.getItem('isDailyChallenge') === 'true';
                if (isDailyChallenge) {
                    gameMode = "classic";
                    if (dailyChallengeIndicator) dailyChallengeIndicator.style.display = 'block';
                    if (puzzleInfoDiv) puzzleInfoDiv.innerHTML = '';
                } else {
                    if (dailyChallengeIndicator) dailyChallengeIndicator.style.display = 'none';
                    gameMode = sessionStorage.getItem('gameMode') || "classic";
                }

                if (gameMode === "countdown" && !isDailyChallenge) {
                    countdownDuration = parseInt(sessionStorage.getItem('countdownDuration'), 10) || 180;
                    timeLeft = countdownDuration;
                    if(timerLabelSpan) timerLabelSpan.textContent = "Time Left: ";
                    timerSpan.classList.add('countdown-active');
                    timerSpan.classList.remove('countdown-warning');
                    timerSpan.style.color = '';
                } else {
                    if(timerLabelSpan) timerLabelSpan.textContent = "Time: ";
                    timerSpan.classList.remove('countdown-active', 'countdown-warning');
                    timerSpan.style.color = '';
                }

                score = STARTING_SCORE;
                if (gameStats.currentStreak > 0 && gameMode === "classic" && !isDailyChallenge) {
                    const puzzleStreakBonus = gameStats.currentStreak * PUZZLE_STREAK_BONUS_PER_STREAK;
                    score += puzzleStreakBonus;
                }

                const puzzleDataString = sessionStorage.getItem(PUZZLE_STORAGE_KEY);
                if (!puzzleDataString) {
                    showError('No puzzle data found. Please start a new game from the home page.');
                    loadingMessage.style.display = 'none'; disableAllInteraction();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'flex';
                    if (viewSolutionBtn) viewSolutionBtn.style.display = 'none';
                    if (newGameBtn) { newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome; }
                    return;
                }
                try {
                    currentPuzzle = JSON.parse(puzzleDataString);
                    if (!currentPuzzle || !currentPuzzle.words || !currentPuzzle.puzzle_id) throw new Error("Invalid puzzle data format.");
                    lives = STARTING_LIVES; hintsUsed = 0;
                    selectedWords = []; solvedGroupKeys = []; revealedGroupsCount = 0; isSubmitting = false;
                    currentGroupStreak = 0;
                    shufflesUsed = 0; // ** NEW: Reset shuffles used **

                    clearFeedback(); solvedGroupsArea.innerHTML = '';
                    errorMessage.style.display = 'none'; errorMessage.textContent = '';
                    loadingMessage.style.display = 'none'; wordGrid.innerHTML = '';
                    if (puzzleInfoDiv && !isDailyChallenge && (currentPuzzle.difficulty || currentPuzzle.puzzle_id)) {
                         const infoP = document.createElement('p'); let infoText = [];
                         if(currentPuzzle.puzzle_id && !currentPuzzle.puzzle_id.startsWith("daily_")) infoText.push(`Puzzle #${currentPuzzle.puzzle_id}`);
                         if(currentPuzzle.difficulty) infoText.push(`Difficulty: ${currentPuzzle.difficulty}`);
                         infoP.textContent = infoText.join(' | ');
                         puzzleInfoDiv.innerHTML = '';
                         puzzleInfoDiv.appendChild(infoP);
                    } else if (puzzleInfoDiv) {
                        puzzleInfoDiv.innerHTML = '';
                    }

                    displayWords(currentPuzzle.words);
                    updateScoreDisplay(); updateLivesDisplay(); updateHintsDisplay(); updateSelectionUI();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'none';
                    enableAllInteraction(); startTime = Date.now();
                    startTimer();
                    gameActive = true;
                    setInitialFocus();
                } catch (error) {
                    console.error("Error initializing game:", error);
                    showError(`Failed to load puzzle: ${error.message}. Please try starting a new game.`);
                    loadingMessage.style.display = 'none'; disableAllInteraction();
                    if (postGameActionsDiv) postGameActionsDiv.style.display = 'flex';
                    if (viewSolutionBtn) viewSolutionBtn.style.display = 'none';
                    if (newGameBtn) { newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome; }
                }
            }

            function displayWords(words) {
                wordGrid.innerHTML = '';
                const shuffledWords = [...words].sort(() => Math.random() - 0.5);
                shuffledWords.forEach((word) => {
                    const wordDiv = document.createElement('div'); wordDiv.classList.add('word-item');
                    wordDiv.textContent = word; wordDiv.dataset.word = word;
                    wordDiv.setAttribute('role', 'gridcell'); wordDiv.setAttribute('aria-selected', 'false');
                    wordDiv.addEventListener('click', handleWordClick); wordDiv.addEventListener('keydown', handleWordKeyDown);
                    wordGrid.appendChild(wordDiv);
                });
            }

            function updateSelectionUI() {
                selectedCountSpan.textContent = selectedWords.length;
                clearSelectionBtn.disabled = selectedWords.length === 0 || isSubmitting || !gameActive;
                hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
                // ** NEW: Update Shuffle Button State **
                if (shuffleBtn) {
                    shuffleBtn.disabled = isSubmitting || !gameActive || revealedGroupsCount === 4 || lives <= 0 || shufflesUsed >= MAX_SHUFFLES_ALLOWED;
                }
            }
            function updateLivesDisplay() {
                 livesRemainingSpan.textContent = lives; const livesDiv = livesRemainingSpan.closest('div');
                 if(livesDiv) {
                    livesDiv.style.color = lives <= 1 ? 'var(--timer-warning-color)' : 'var(--text-secondary)';
                    livesRemainingSpan.style.color = lives <= 1 ? 'var(--timer-warning-color)' : 'var(--accent-primary)';
                 }
            }
            function updateScoreDisplay() { scoreSpan.textContent = Math.max(0, score); }
            function updateHintsDisplay() {
                 hintsUsedSpan.textContent = hintsUsed; hintsAllowedSpan.textContent = MAX_HINTS;
                 hintBtn.disabled = isSubmitting || !gameActive || hintsUsed >= MAX_HINTS || revealedGroupsCount === 4 || lives <= 0;
            }

            function startTimer() {
                stopTimer();
                if (gameMode === "countdown") {
                    timerSpan.classList.add('countdown-active');
                    timerSpan.classList.remove('countdown-warning');
                    timerSpan.style.color = '';
                    timeLeft = countdownDuration;
                    updateTimerDisplay();

                    timerInterval = setInterval(() => {
                        if (!gameActive) return;
                        timeLeft--;
                        updateTimerDisplay();

                        if (timeLeft <= 10 && timeLeft > 0) {
                            timerSpan.classList.add('countdown-warning');
                        } else if (timeLeft <= 0) {
                            stopTimer();
                            showFeedback("Time's up! Puzzle failed.", 'feedback-incorrect', 0);
                            playSound(loseSound);
                            endGame(false);
                        }
                    }, 1000);
                } else {
                    timerSpan.classList.remove('countdown-active', 'countdown-warning');
                    timerSpan.style.color = '';
                    timerInterval = setInterval(() => {
                        if (!gameActive || !startTime) return;
                        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                        const minutes = Math.floor(elapsedSeconds / 60);
                        const seconds = elapsedSeconds % 60;
                        timerSpan.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                    }, 1000);
                }
            }
            function updateTimerDisplay() {
                if (gameMode === "countdown") {
                    const minutes = Math.floor(Math.max(0, timeLeft) / 60);
                    const seconds = Math.max(0, timeLeft) % 60;
                    timerSpan.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }
            function stopTimer() { clearInterval(timerInterval); timerInterval = null; }

            function handleWordClick(event) {
                 const wordDiv = event.currentTarget;
                 if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                 toggleWordSelection(wordDiv);
            }
            function handleWordKeyDown(event) {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault(); const wordDiv = event.currentTarget;
                    if (!gameActive || isSubmitting || wordDiv.classList.contains('solved') || wordDiv.classList.contains('disabled')) return;
                    toggleWordSelection(wordDiv);
                }
            }
            function toggleWordSelection(wordDiv) {
                 const word = wordDiv.dataset.word; const isSelected = wordDiv.classList.contains('selected');
                 clearFeedback();
                 if (isSelected) {
                      selectedWords = selectedWords.filter(w => w !== word);
                      wordDiv.classList.remove('selected'); wordDiv.setAttribute('aria-selected', 'false');
                 } else {
                      if (selectedWords.length < 4) {
                           selectedWords.push(word); wordDiv.classList.add('selected');
                           wordDiv.setAttribute('aria-selected', 'true');
                           playSound(selectSound);
                      }
                 }
                 updateSelectionUI();
                 if (selectedWords.length === 4) setTimeout(submitGroupAttempt, 150);
            }
            function clearSelection() {
                 clearFeedback(); selectedWords = [];
                 document.querySelectorAll('.word-item.selected').forEach(el => {
                    el.classList.remove('selected'); el.setAttribute('aria-selected', 'false');
                 });
                 updateSelectionUI();
            }

            async function handleHintClick() {
                if (!gameActive || isSubmitting || hintsUsed >= MAX_HINTS || lives <= 0) return;
                isSubmitting = true; updateSelectionUI();
                score -= HINT_PENALTY; hintsUsed++;
                updateScoreDisplay(); updateHintsDisplay(); clearFeedback();
                try {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const response = await fetch('/api/get_hint', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ puzzle_id: currentPuzzle.puzzle_id, solved_group_keys: solvedGroupKeys }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: `HTTP error ${response.status}` }));
                        throw new Error(errorData.detail || `Hint Error: ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.hint && result.words && Array.isArray(result.words)) {
                        showFeedback(result.hint, 'feedback-hint', 5000); highlightHintWords(result.words);
                        if (hintsUsed >= MAX_HINTS) { isSubmitting = false; updateSelectionUI(); setTimeout(openShowAnswerModal, 1000); }
                        else { isSubmitting = false; updateSelectionUI(); }
                    } else if (result.hint) {
                         showFeedback(result.hint, 'feedback-hint', hintsUsed >= MAX_HINTS ? 5000 : 4000);
                         if (hintsUsed >= MAX_HINTS) { isSubmitting = false; updateSelectionUI(); setTimeout(openShowAnswerModal, 1000); }
                         else { isSubmitting = false; updateSelectionUI(); }
                    } else {
                        showFeedback(result.message || "No hint available.", '', 3000);
                        if (hintsUsed > 0) { hintsUsed--; score += HINT_PENALTY; updateScoreDisplay(); updateHintsDisplay(); }
                        isSubmitting = false; updateSelectionUI();
                    }
                } catch (error) {
                    console.error('Error getting hint:', error);
                    showFeedback(`Hint Failed: ${error.message}`, 'feedback-incorrect', 4000);
                    let baseScore = STARTING_SCORE;
                    if (gameMode === "classic" && gameStats.currentStreak > 0 && !isDailyChallenge) {
                        baseScore += gameStats.currentStreak * PUZZLE_STREAK_BONUS_PER_STREAK;
                    }
                    if(hintsUsed > 0 && score + HINT_PENALTY <= baseScore + (MAX_HINTS * HINT_PENALTY) ) {
                         hintsUsed--; score += HINT_PENALTY;
                    }
                    updateScoreDisplay(); updateHintsDisplay(); isSubmitting = false; updateSelectionUI();
                }
            }
            function highlightHintWords(wordsArray) {
                if (hintHighlightTimeout) clearTimeout(hintHighlightTimeout);
                document.querySelectorAll('.word-item.highlight-hint').forEach(el => el.classList.remove('highlight-hint'));
                if (!wordsArray || wordsArray.length === 0) return;
                wordsArray.forEach(word => {
                    const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]:not(.solved)`);
                    if (wordDiv) wordDiv.classList.add('highlight-hint');
                });
                hintHighlightTimeout = setTimeout(() => {
                    document.querySelectorAll('.word-item.highlight-hint').forEach(el => el.classList.remove('highlight-hint'));
                    hintHighlightTimeout = null;
                }, 5000);
            }

            function clearFeedback() {
                if (feedbackTimeout) clearTimeout(feedbackTimeout); feedbackTimeout = null;
                if (feedbackArea) {
                    feedbackArea.textContent = ''; feedbackArea.className = '';
                    feedbackArea.classList.add('feedback-area');
                }
            }
            function showFeedback(message, className = '', duration = 3000) {
                 if (!feedbackArea) return; clearFeedback();
                 feedbackArea.textContent = message;
                 if (className) feedbackArea.classList.add(className);
                 if (duration > 0) {
                     feedbackTimeout = setTimeout(() => {
                         if (feedbackArea && feedbackArea.textContent === message) clearFeedback();
                     }, duration);
                 }
            }
            function showError(message) { errorMessage.textContent = message; errorMessage.style.display = 'block'; }

            async function submitGroupAttempt() {
                if (!gameActive || isSubmitting || selectedWords.length !== 4 || lives <= 0) return;
                isSubmitting = true; updateSelectionUI(); clearFeedback(); showFeedback('Checking...', '', 0);
                const attemptPayload = { puzzle_id: currentPuzzle.puzzle_id, groups: { 'attempt': selectedWords } };
                await new Promise(resolve => setTimeout(resolve, 300));
                try {
                    const response = await fetch('/api/check_answer', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(attemptPayload)
                    });
                    if (!response.ok) {
                        let errorText = `Check Error: ${response.status}`;
                        try { const errorData = await response.json(); errorText = errorData.detail || errorText; } catch (e) {}
                        throw new Error(errorText);
                    }
                    const result = await response.json(); handleAttemptResult(result);
                } catch (error) {
                     console.error('Error submitting answer:', error);
                     showFeedback(`Failed to check answer: ${error.message}. Try again.`, 'feedback-incorrect', 4000);
                     clearSelection();
                } finally { isSubmitting = false; }
            }

            function handleAttemptResult(result) {
                 let foundCorrectGroup = false; let correctGroupDescription = "";
                 let newlySolvedKey = null; let difficultyIndex = revealedGroupsCount;
                 const currentResultSolvedKeys = Object.keys(result.solved_groups || {});
                 const justSolvedKeys = currentResultSolvedKeys.filter(key => !solvedGroupKeys.includes(key));

                 if (justSolvedKeys.length > 0) {
                     foundCorrectGroup = true; newlySolvedKey = justSolvedKeys[0];
                     const solvedGroupData = result.solved_groups[newlySolvedKey];
                      if (typeof solvedGroupData === 'object' && solvedGroupData !== null) {
                         correctGroupDescription = solvedGroupData.description || "Group Found";
                         difficultyIndex = solvedGroupData.difficulty_index !== undefined ? solvedGroupData.difficulty_index : revealedGroupsCount;
                      } else if (typeof solvedGroupData === 'string') { correctGroupDescription = solvedGroupData; }
                     if (!solvedGroupKeys.includes(newlySolvedKey)) solvedGroupKeys.push(newlySolvedKey);
                 }

                  if (foundCorrectGroup) {
                       playSound(correctSound);
                       score += POINTS_PER_CORRECT_GROUP;
                       currentGroupStreak++;

                       if (currentGroupStreak >= GROUP_STREAK_THRESHOLD) {
                           const groupStreakBonus = (currentGroupStreak - (GROUP_STREAK_THRESHOLD - 1)) * GROUP_STREAK_BONUS_MULTIPLIER;
                           score += groupStreakBonus;
                           showFeedback(`Correct! Group Streak: +${groupStreakBonus}pts!`, 'feedback-correct', 2000);
                       } else {
                           showFeedback(result.message || "Correct!", 'feedback-correct', 1500);
                       }
                       updateScoreDisplay();
                       const wordsInSolvedGroupForAnim = selectedWords.slice();
                       wordsInSolvedGroupForAnim.forEach(word => {
                           const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]`);
                           if (wordDiv) {
                               wordDiv.classList.add('correct-match-animation');
                               wordDiv.addEventListener('animationend', () => {
                                   wordDiv.classList.remove('correct-match-animation');
                               }, { once: true });
                           }
                       });
                       setTimeout(() => {
                           displaySolvedGroup(correctGroupDescription, wordsInSolvedGroupForAnim, difficultyIndex);
                           revealedGroupsCount++; selectedWords = []; updateSelectionUI();
                           if (revealedGroupsCount === 4) {
                                setTimeout(() => {
                                    showFeedback("Congratulations! Puzzle Solved!", 'feedback-correct', 0);
                                    playSound(winSound); endGame(true);
                                }, 300);
                           }
                       }, 600);
                  } else {
                       playSound(incorrectSound);
                       currentGroupStreak = 0;
                       score -= INCORRECT_GUESS_PENALTY;
                       lives--;
                       updateScoreDisplay(); updateLivesDisplay();
                       showFeedback(result.message || "Incorrect. Try again.", 'feedback-incorrect', 1800);
                       shakeWords();
                       if (lives <= 0) {
                            setTimeout(() => {
                                showFeedback("Game Over! You're out of mistakes.", 'feedback-incorrect', 0);
                                playSound(loseSound); endGame(false);
                            }, 600);
                       } else { setTimeout(clearSelection, 800); }
                  }
            }
            function displaySolvedGroup(description, wordsInGroup, colorIndex) {
                 const groupDiv = document.createElement('div'); groupDiv.classList.add('solved-group');
                 const actualColorIndex = Math.min(Math.max(colorIndex, 0), 3);
                 groupDiv.classList.add(`solved-group-color-${actualColorIndex}`);
                 groupDiv.dataset.words = JSON.stringify(wordsInGroup);
                 const descStrong = document.createElement('strong'); descStrong.textContent = description; groupDiv.appendChild(descStrong);
                 const wordsP = document.createElement('p'); wordsP.textContent = wordsInGroup.sort().join(', '); groupDiv.appendChild(wordsP);
                 if (solvedGroupsArea.firstChild) solvedGroupsArea.insertBefore(groupDiv, solvedGroupsArea.firstChild);
                 else solvedGroupsArea.appendChild(groupDiv);
                 wordsInGroup.forEach(word => {
                       const wordDiv = wordGrid.querySelector(`.word-item[data-word="${word}"]`);
                       if (wordDiv) {
                            wordDiv.classList.add('solved'); wordDiv.classList.remove('selected', 'highlight-hint', 'correct-match-animation');
                            wordDiv.removeEventListener('click', handleWordClick); wordDiv.removeEventListener('keydown', handleWordKeyDown);
                            wordDiv.style.cursor = 'default'; wordDiv.setAttribute('aria-selected', 'false');
                            wordDiv.setAttribute('aria-disabled', 'true'); wordDiv.removeAttribute('tabindex');
                       }
                  });
                 reorderGrid();
            }
            function reorderGrid() {
                const solvedItems = Array.from(wordGrid.querySelectorAll('.word-item.solved'));
                const activeItems = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved)'));
                wordGrid.innerHTML = '';
                activeItems.forEach(item => wordGrid.appendChild(item));
                solvedItems.forEach(item => wordGrid.appendChild(item));
            }
            function shakeWords() {
                 document.querySelectorAll('.word-item.selected').forEach(div => {
                      div.style.animation = 'none'; void div.offsetWidth;
                      div.style.animation = 'shake 0.5s ease-in-out';
                 });
            }

            // ****** NEW: Shuffle Grid Function ******
            function shuffleWordGrid() {
                if (!gameActive || isSubmitting || shufflesUsed >= MAX_SHUFFLES_ALLOWED) {
                    if (shufflesUsed >= MAX_SHUFFLES_ALLOWED) {
                        showFeedback("No more shuffles allowed for this puzzle.", "", 2000);
                    }
                    return;
                }

                if (selectedWords.length > 0) {
                    clearSelection(); // Clear selection before shuffling
                }
                clearFeedback();

                const activeWordDivs = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved)'));
                const activeWordsData = activeWordDivs.map(div => div.dataset.word);

                // Simple shuffle: Fisher-Yates on the data array
                for (let i = activeWordsData.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [activeWordsData[i], activeWordsData[j]] = [activeWordsData[j], activeWordsData[i]];
                }

                // Re-assign words to existing (unsolved) divs
                activeWordDivs.forEach((div, index) => {
                    div.textContent = activeWordsData[index];
                    div.dataset.word = activeWordsData[index];
                });

                shufflesUsed++;
                score -= SHUFFLE_PENALTY_SCORE; // Apply penalty
                updateScoreDisplay();
                updateSelectionUI(); // This will update shuffle button state if max shuffles reached

                playSound(shuffleSound);
                showFeedback(`Words shuffled! (${MAX_SHUFFLES_ALLOWED - shufflesUsed} shuffles remaining)`, "", 2000);
                setInitialFocus(); // Or focus the first active word item
            }
            // ****** END: Shuffle Grid Function ******


            function endGame(isWin) {
                 if (!gameActive) return; gameActive = false;
                 stopTimer(); disableAllInteraction(); closeShowAnswerModal();

                 if (isWin) {
                    if (gameMode === "classic" && !isDailyChallenge) {
                        const now = Date.now();
                        const elapsedSeconds = startTime ? Math.floor((now - startTime) / 1000) : Infinity;
                        let timeBonus = 0;
                        if (elapsedSeconds < TIME_BONUS_TARGET_SECONDS) {
                            timeBonus = (TIME_BONUS_TARGET_SECONDS - elapsedSeconds) * TIME_BONUS_PER_SECOND_SAVED;
                            score += timeBonus;
                        }
                    } else if (gameMode === "countdown" && !isDailyChallenge) {
                        if (timeLeft > 0) {
                           score += timeLeft * COUNTDOWN_WIN_BONUS_PER_SECOND;
                        }
                    }
                 }
                 score = Math.max(0, score); updateScoreDisplay();

                 const endTime = Date.now();
                 const solveTimeSeconds = startTime ? Math.floor((endTime - startTime) / 1000) : null;

                 if (!isDailyChallenge) {
                    if (isWin) {
                        gameStats.wins++; gameStats.currentStreak++;
                        gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                        if (gameMode === "classic" && solveTimeSeconds !== null && (gameStats.fastestTime === null || solveTimeSeconds < gameStats.fastestTime)) {
                            gameStats.fastestTime = solveTimeSeconds;
                        }
                        if (hintsUsed === 0 && lives === STARTING_LIVES) {
                            gameStats.perfectWins = (gameStats.perfectWins || 0) + 1;
                        }
                    } else {
                        gameStats.losses++; gameStats.currentStreak = 0;
                    }
                    saveStats();
                 } else if (isWin) {
                     console.info("Daily challenge completed successfully!");
                 }


                if (postGameActionsDiv) {
                    postGameActionsDiv.style.display = 'flex';
                    postGameActionsDiv.style.justifyContent = 'center';
                    postGameActionsDiv.style.gap = '15px';
                }
                if (newGameBtn) {
                     newGameBtn.style.display = 'inline-flex'; newGameBtn.onclick = goToHome;
                }
                if (viewSolutionBtn) {
                    viewSolutionBtn.style.display = 'inline-flex';
                    viewSolutionBtn.disabled = false;
                    viewSolutionBtn.innerHTML = '<i class="fas fa-eye"></i> View Solution';
                    viewSolutionBtn.onclick = async () => {
                        viewSolutionBtn.disabled = true;
                        viewSolutionBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Revealing...';
                        await revealAllGroups();
                    };
                }
                addPostGameReviewListeners();
            }

            async function revealAllGroups() {
                if (!currentPuzzle?.puzzle_id) return;
                if (gameActive) { gameActive = false; stopTimer(); }
                clearFeedback(); showFeedback('Revealing solution...', '', 0);
                try {
                     await new Promise(resolve => setTimeout(resolve, 400));
                     const response = await fetch(`/api/get_solution/${currentPuzzle.puzzle_id}`);
                     if (!response.ok) throw new Error('Could not fetch solution from server.');
                     const solution = await response.json();
                     if (!solution || !solution.groups || typeof solution.groups !== 'object') {
                        throw new Error("Invalid solution format received from server.");
                     }
                     solvedGroupsArea.innerHTML = '';
                     wordGrid.querySelectorAll('.word-item').forEach(el => {
                          el.classList.remove('solved', 'disabled', 'selected', 'highlight-hint', 'highlight-review', 'correct-match-animation');
                          el.style.animation = '';
                     });
                     let colorIdx = 0;
                     for (const groupKey in solution.groups) {
                        if (Object.hasOwnProperty.call(solution.groups, groupKey)) {
                            const groupData = solution.groups[groupKey];
                            const groupDesc = groupData.description || "Group " + (colorIdx + 1);
                            const groupWords = groupData.words || [];
                            const groupColor = groupData.difficulty_index ?? colorIdx;
                            displaySolvedGroup(groupDesc, groupWords, groupColor);
                            colorIdx++;
                        }
                     }
                     reorderGrid(); clearFeedback(); showFeedback('Solution Revealed.', '', 3000);
                } catch (error) {
                    console.error("Failed to reveal solution:", error);
                    showFeedback(`Could not load the full solution: ${error.message}`, 'feedback-incorrect', 3000);
                } finally {
                    disableAllInteraction();
                    if (viewSolutionBtn && viewSolutionBtn.innerHTML.includes('Revealing...')) {
                         viewSolutionBtn.innerHTML = '<i class="fas fa-check"></i> Solution Shown';
                         viewSolutionBtn.disabled = true;
                    }
                    addPostGameReviewListeners();
                }
            }

            function disableAllInteraction() {
                 wordGrid.removeEventListener('keydown', actualGridNavigationHandler);
                 document.querySelectorAll('.word-item').forEach(el => {
                      el.removeEventListener('click', handleWordClick); el.removeEventListener('keydown', handleWordKeyDown);
                      el.style.cursor = 'default'; el.style.animation = '';
                      if (!el.classList.contains('solved')) {
                          el.classList.add('disabled'); el.classList.remove('selected');
                          el.setAttribute('aria-selected', 'false');
                      }
                     el.setAttribute('aria-disabled', 'true'); el.removeAttribute('tabindex');
                 });
                 clearSelectionBtn.disabled = true;
                 hintBtn.disabled = true;
                 if(shuffleBtn) shuffleBtn.disabled = true; // ** NEW: Disable shuffle btn **
            }
            function enableAllInteraction() {
                 document.querySelectorAll('.word-item:not(.solved)').forEach(el => {
                     el.addEventListener('click', handleWordClick); el.addEventListener('keydown', handleWordKeyDown);
                     el.style.cursor = 'pointer'; el.classList.remove('disabled');
                     el.setAttribute('aria-disabled', 'false'); el.setAttribute('tabindex', '0');
                 });
                 updateSelectionUI(); // This will correctly set disabled state of shuffleBtn too
                 setupGridNavigation();
            }
            function goToHome() {
                sessionStorage.removeItem(PUZZLE_STORAGE_KEY);
                sessionStorage.removeItem('gameMode');
                sessionStorage.removeItem('countdownDuration');
                sessionStorage.removeItem('isDailyChallenge');
                document.body.classList.add('fade-out');
                setTimeout(() => { window.location.href = '/home.html'; }, 300);
            }

            function loadStats() {
                const storedStats = localStorage.getItem(STATS_STORAGE_KEY);
                let defaultStats = { wins: 0, losses: 0, currentStreak: 0, maxStreak: 0, fastestTime: null, perfectWins: 0 };
                if (storedStats) {
                    try {
                        const parsedStats = JSON.parse(storedStats);
                        gameStats = { ...defaultStats, ...parsedStats };
                    } catch (e) {
                        localStorage.removeItem(STATS_STORAGE_KEY);
                        gameStats = { ...defaultStats };
                        console.error("Error loading/parsing stats, resetting to default:", e);
                    }
                } else {
                    gameStats = { ...defaultStats };
                }
            }
            function saveStats() {
                try { localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(gameStats)); } catch (e) { console.error('Error saving stats:', e); }
            }
            function setInitialFocus() {
                const firstFocusableWord = wordGrid.querySelector('.word-item:not(.solved):not(.disabled)');
                if (firstFocusableWord) firstFocusableWord.focus();
                else if (newGameBtn && newGameBtn.style.display !== 'none') newGameBtn.focus();
                else if (hintBtn && !hintBtn.disabled) hintBtn.focus();
            }
            const actualGridNavigationHandler = (event) => {
                const { key } = event; const activeElement = document.activeElement;
                if (!activeElement || !activeElement.classList.contains('word-item') || !wordGrid.contains(activeElement) || activeElement.classList.contains('solved') || activeElement.classList.contains('disabled')) return;
                if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) return;
                event.preventDefault();
                const focusableItems = Array.from(wordGrid.querySelectorAll('.word-item:not(.solved):not(.disabled)'));
                if (focusableItems.length === 0) return;
                let currentIndex = focusableItems.indexOf(activeElement);
                if (currentIndex === -1) { if(focusableItems.length > 0) focusableItems[0].focus(); return; }
                const numCols = window.innerWidth <= 480 ? 2 : 4; let targetIndex = -1;
                switch (key) {
                    case 'ArrowUp':   targetIndex = currentIndex - numCols; break;
                    case 'ArrowDown': targetIndex = currentIndex + numCols; break;
                    case 'ArrowLeft': if (currentIndex % numCols !== 0) targetIndex = currentIndex - 1; break;
                    case 'ArrowRight': if ((currentIndex % numCols < numCols - 1) && currentIndex < focusableItems.length - 1) targetIndex = currentIndex + 1; break;
                }
                if (targetIndex >= 0 && targetIndex < focusableItems.length) focusableItems[targetIndex].focus();
            };
            function setupGridNavigation() {
                wordGrid.removeEventListener('keydown', actualGridNavigationHandler);
                wordGrid.addEventListener('keydown', actualGridNavigationHandler);
            }
            function addPostGameReviewListeners() {
                const solvedGroupDivs = solvedGroupsArea.querySelectorAll('.solved-group');
                solvedGroupDivs.forEach(groupDiv => {
                    groupDiv.classList.add('reviewable'); groupDiv.setAttribute('tabindex', '0');
                    groupDiv.addEventListener('click', handleReviewGroupClick);
                    groupDiv.addEventListener('keydown', (event) => { if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); handleReviewGroupClick(event); }});
                });
            }
            function handleReviewGroupClick(event) {
                const groupDiv = event.currentTarget; const wordsToHighlight = JSON.parse(groupDiv.dataset.words || '[]');
                wordGrid.querySelectorAll('.word-item.highlight-review').forEach(el => el.classList.remove('highlight-review'));
                wordsToHighlight.forEach(word => { const wordItem = wordGrid.querySelector(`.word-item.solved[data-word="${word}"]`); if (wordItem) wordItem.classList.add('highlight-review'); });
            }
            function openShowAnswerModal() {
                if (showAnswerModal) { elementToFocusOnModalClose = document.activeElement; currentOpenModal = showAnswerModal; showAnswerModal.style.display = 'flex'; setTimeout(() => { showAnswerModal.classList.add('modal-open'); modalFocusableElements = Array.from(showAnswerModal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el => el.offsetParent !== null); if (modalFocusableElements.length > 0) modalFocusableElements[0].focus(); document.addEventListener('keydown', handleModalFocusTrap); }, 10); }
            }
            function closeShowAnswerModal() {
                if (showAnswerModal && currentOpenModal === showAnswerModal) { document.removeEventListener('keydown', handleModalFocusTrap); showAnswerModal.classList.remove('modal-open'); currentOpenModal = null; setTimeout(() => { if (!showAnswerModal.classList.contains('modal-open')) showAnswerModal.style.display = 'none'; if (elementToFocusOnModalClose) { elementToFocusOnModalClose.focus(); elementToFocusOnModalClose = null; } }, 300); }
            }
            function handleModalFocusTrap(event) {
                if (!currentOpenModal || !currentOpenModal.classList.contains('modal-open')) return; if (event.key === 'Tab') { if (modalFocusableElements.length === 0) { event.preventDefault(); return; } const firstElement = modalFocusableElements[0]; const lastElement = modalFocusableElements[modalFocusableElements.length - 1]; if (event.shiftKey) { if (document.activeElement === firstElement) { lastElement.focus(); event.preventDefault(); } } else { if (document.activeElement === lastElement) { firstElement.focus(); event.preventDefault(); } } } else if (event.key === 'Escape') { if (currentOpenModal === showAnswerModal) closeShowAnswerModal(); }
            }

            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark-theme');
                    if (themeToggleBtn) themeToggleBtn.innerHTML = `<i class="fas ${sunIconClass}"></i>`;
                    localStorage.setItem(THEME_STORAGE_KEY, 'dark');
                } else {
                    document.documentElement.classList.remove('dark-theme');
                    if (themeToggleBtn) themeToggleBtn.innerHTML = `<i class="fas ${moonIconClass}"></i>`;
                    localStorage.setItem(THEME_STORAGE_KEY, 'light');
                }
            }
            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', () => {
                    if (document.documentElement.classList.contains('dark-theme')) applyTheme('light');
                    else applyTheme('dark');
                });
            }
            const savedTheme = localStorage.getItem(THEME_STORAGE_KEY);
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme) applyTheme(savedTheme); else if (prefersDark) applyTheme('dark'); else applyTheme('light');

            clearSelectionBtn.addEventListener('click', clearSelection);
            hintBtn.addEventListener('click', handleHintClick);
            if(shuffleBtn) shuffleBtn.addEventListener('click', shuffleWordGrid); // ** NEW: Attach listener **
            confirmShowAnswerBtn.addEventListener('click', async () => { closeShowAnswerModal(); await revealAllGroups(); });
            cancelShowAnswerBtn.addEventListener('click', closeShowAnswerModal);

            initGame();
        });
    </script>
</body>
</html>